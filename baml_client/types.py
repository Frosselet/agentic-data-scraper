# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
import typing_extensions
from enum import Enum


from pydantic import BaseModel, ConfigDict


import baml_py

CheckT = typing_extensions.TypeVar('CheckT')
CheckName = typing_extensions.TypeVar('CheckName', bound=str)

class Check(BaseModel):
    name: str
    expression: str
    status: str
class Checked(BaseModel, typing.Generic[CheckT, CheckName]):
    value: CheckT
    checks: typing.Dict[CheckName, Check]

def get_checks(checks: typing.Dict[CheckName, Check]) -> typing.List[Check]:
    return list(checks.values())

def all_succeeded(checks: typing.Dict[CheckName, Check]) -> bool:
    return all(check.status == "succeeded" for check in get_checks(checks))
# #########################################################################
# Generated enums (3)
# #########################################################################

class NavigationPriority(str, Enum):
    COST_OPTIMIZATION = "COST_OPTIMIZATION"
    TIME_CRITICAL = "TIME_CRITICAL"
    RISK_MITIGATION = "RISK_MITIGATION"
    FUEL_EFFICIENCY = "FUEL_EFFICIENCY"
    RELIABILITY = "RELIABILITY"

class RiskLevel(str, Enum):
    LOW = "LOW"
    MODERATE = "MODERATE"
    HIGH = "HIGH"
    CRITICAL = "CRITICAL"

class TransportMode(str, Enum):
    RIVER = "RIVER"
    RAIL = "RAIL"
    TRUCK = "TRUCK"
    MULTIMODAL = "MULTIMODAL"

# #########################################################################
# Generated classes (21)
# #########################################################################

class AgriculturePipelineConfig(BaseModel):
    ontologies: typing.List[str]
    data_sources: typing.List[str]
    quality_thresholds: typing.Dict[str, float]

class BusinessContext(BaseModel):
    question: str
    success_criteria: str
    timeline: str
    budget: str
    risk_tolerance: str
    persona_id: str
    interaction_level: str

class CongestionAlert(BaseModel):
    location: str
    river_mile: float
    severity: RiskLevel
    estimated_delay_hours: float
    affected_vessels: int
    alternative_routes: typing.List[str]
    cost_impact_percent: float

class DataContract(BaseModel):
    source_requirements: typing.List[str]
    validation_rules: typing.List[str]
    transformation_specs: typing.List[str]
    quality_thresholds: typing.Dict[str, float]
    security_requirements: typing.List[str]
    compliance_rules: typing.List[str]

class DataSource(BaseModel):
    type: str
    url: typing.Optional[str] = None
    authentication_type: typing.Optional[str] = None
    access_patterns: typing.List[str]
    rate_limits: typing.Optional[int] = None
    documentation_url: typing.Optional[str] = None

class DataSourceRecommendation(BaseModel):
    name: str
    type: str
    description: str
    feasibility_score: float
    cost_estimate: str
    implementation_effort: str
    platform_compatibility: float
    data_quality_expected: float
    access_requirements: typing.List[str]
    sample_data_url: typing.Optional[str] = None
    documentation_url: typing.Optional[str] = None
    pros: typing.List[str]
    cons: typing.List[str]
    semantic_vocabularies: typing.List[str]

class FeasibilityAnalysis(BaseModel):
    overall_feasibility: str
    technical_risks: typing.List[str]
    business_risks: typing.List[str]
    mitigation_strategies: typing.List[str]
    platform_gaps: typing.List[str]
    recommended_alternatives: typing.List[str]
    estimated_timeline_weeks: int
    confidence_level: float

class GeneratedPipeline(BaseModel):
    lambda_code: str
    deployment_config: str
    monitoring_code: str
    validation_code: str
    documentation: str
    test_cases: typing.List[str]

class MarketOpportunity(BaseModel):
    commodity: str
    origin_price: float
    destination_price: float
    arbitrage_potential: float
    transport_cost: float
    net_profit_per_ton: float
    market_window_days: int
    confidence_level: float

class NavigationRecommendation(BaseModel):
    recommended_route: "RouteOption"
    alternative_routes: typing.List["RouteOption"]
    risk_factors: typing.List[str]
    cost_analysis: typing.Dict[str, float]
    timing_considerations: typing.List[str]
    weather_alerts: typing.List[str]
    market_insights: typing.List[str]
    action_items: typing.List[str]
    decision_rationale: str

class ParsedData(BaseModel):
    format: str
    schema: typing.Dict[str, str]
    quality_score: float
    anomalies: typing.List[str]
    encoding: typing.Optional[str] = None
    size_mb: float

class RouteOption(BaseModel):
    route_id: str
    transport_mode: TransportMode
    total_distance_miles: float
    estimated_travel_time_hours: float
    total_cost_usd: float
    risk_assessment: RiskLevel
    fuel_cost: float
    lock_fees: typing.List[float]
    delay_probability: float
    confidence_score: float
    route_segments: typing.List[str]
    alternative_modes: typing.List[str]
    cost_breakdown: typing.Dict[str, float]

class RoutingRequest(BaseModel):
    origin_port: str
    destination_port: str
    commodity: str
    quantity_tons: float
    departure_time: str
    priority: NavigationPriority
    max_delay_hours: typing.Optional[int] = None
    budget_constraint: typing.Optional[float] = None
    vessel_specs: typing.Optional["VesselSpecifications"] = None

class SOWContract(BaseModel):
    project_title: str
    executive_summary: str
    business_objectives: typing.List[str]
    success_metrics: typing.List[str]
    data_sources: typing.List["DataSourceRecommendation"]
    technical_approach: str
    deliverables: typing.List[str]
    timeline_weeks: int
    cost_estimate: str
    risk_assessment: str
    acceptance_criteria: typing.List[str]
    semantic_framework: str

class SecurityDecision(BaseModel):
    risk_level: str
    decision_required: str
    context: str
    recommended_action: str
    human_approval_needed: bool

class SemanticAnnotation(BaseModel):
    ontology_mappings: typing.Dict[str, str]
    skos_concepts: typing.List[str]
    owl_alignments: typing.List[str]
    semantic_quality_score: float
    domain_coverage: float
    linked_entities: typing.List[str]

class SupplyChainPipelineConfig(BaseModel):
    ontologies: typing.List[str]
    data_sources: typing.List[str]
    quality_thresholds: typing.Dict[str, float]

class TradingPipelineConfig(BaseModel):
    ontologies: typing.List[str]
    data_sources: typing.List[str]
    quality_thresholds: typing.Dict[str, float]

class TransformationStrategy(BaseModel):
    source_schema: typing.Dict[str, str]
    target_schema: typing.Dict[str, str]
    transformation_rules: typing.List[str]
    validation_logic: typing.List[str]
    performance_optimizations: typing.List[str]
    error_handling: typing.List[str]

class VesselSpecifications(BaseModel):
    vessel_id: str
    vessel_type: str
    length: float
    width: float
    draft: float
    cargo_capacity: float
    current_load: float
    fuel_consumption: float

class WaterwayConditions(BaseModel):
    water_level: float
    flow_rate: float
    navigation_status: str
    ice_conditions: typing.Optional[str] = None
    weather_impact: typing.Optional[str] = None
    lock_delays: typing.List[int]
    depth_restrictions: typing.List[float]

# #########################################################################
# Generated type aliases (0)
# #########################################################################
