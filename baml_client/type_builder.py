# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
from baml_py import type_builder
from baml_py import baml_py
# These are exports, not used here, hence the linter is disabled
from baml_py.baml_py import FieldType, EnumValueBuilder, EnumBuilder, ClassBuilder # noqa: F401 # pylint: disable=unused-import
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME

class TypeBuilder(type_builder.TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["AgriculturePipelineConfig","BusinessContext","CongestionAlert","DataContract","DataSource","DataSourceRecommendation","FeasibilityAnalysis","GeneratedPipeline","MarketOpportunity","NavigationRecommendation","ParsedData","RouteOption","RoutingRequest","SOWContract","SecurityDecision","SemanticAnnotation","SupplyChainPipelineConfig","TradingPipelineConfig","TransformationStrategy","VesselSpecifications","WaterwayConditions",]
        ), enums=set(
          ["NavigationPriority","RiskLevel","TransportMode",]
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)

    # #########################################################################
    # Generated enums 3
    # #########################################################################

    @property
    def NavigationPriority(self) -> "NavigationPriorityViewer":
        return NavigationPriorityViewer(self)

    @property
    def RiskLevel(self) -> "RiskLevelViewer":
        return RiskLevelViewer(self)

    @property
    def TransportMode(self) -> "TransportModeViewer":
        return TransportModeViewer(self)


    # #########################################################################
    # Generated classes 21
    # #########################################################################

    @property
    def AgriculturePipelineConfig(self) -> "AgriculturePipelineConfigViewer":
        return AgriculturePipelineConfigViewer(self)

    @property
    def BusinessContext(self) -> "BusinessContextViewer":
        return BusinessContextViewer(self)

    @property
    def CongestionAlert(self) -> "CongestionAlertViewer":
        return CongestionAlertViewer(self)

    @property
    def DataContract(self) -> "DataContractViewer":
        return DataContractViewer(self)

    @property
    def DataSource(self) -> "DataSourceViewer":
        return DataSourceViewer(self)

    @property
    def DataSourceRecommendation(self) -> "DataSourceRecommendationViewer":
        return DataSourceRecommendationViewer(self)

    @property
    def FeasibilityAnalysis(self) -> "FeasibilityAnalysisViewer":
        return FeasibilityAnalysisViewer(self)

    @property
    def GeneratedPipeline(self) -> "GeneratedPipelineViewer":
        return GeneratedPipelineViewer(self)

    @property
    def MarketOpportunity(self) -> "MarketOpportunityViewer":
        return MarketOpportunityViewer(self)

    @property
    def NavigationRecommendation(self) -> "NavigationRecommendationViewer":
        return NavigationRecommendationViewer(self)

    @property
    def ParsedData(self) -> "ParsedDataViewer":
        return ParsedDataViewer(self)

    @property
    def RouteOption(self) -> "RouteOptionViewer":
        return RouteOptionViewer(self)

    @property
    def RoutingRequest(self) -> "RoutingRequestViewer":
        return RoutingRequestViewer(self)

    @property
    def SOWContract(self) -> "SOWContractViewer":
        return SOWContractViewer(self)

    @property
    def SecurityDecision(self) -> "SecurityDecisionViewer":
        return SecurityDecisionViewer(self)

    @property
    def SemanticAnnotation(self) -> "SemanticAnnotationViewer":
        return SemanticAnnotationViewer(self)

    @property
    def SupplyChainPipelineConfig(self) -> "SupplyChainPipelineConfigViewer":
        return SupplyChainPipelineConfigViewer(self)

    @property
    def TradingPipelineConfig(self) -> "TradingPipelineConfigViewer":
        return TradingPipelineConfigViewer(self)

    @property
    def TransformationStrategy(self) -> "TransformationStrategyViewer":
        return TransformationStrategyViewer(self)

    @property
    def VesselSpecifications(self) -> "VesselSpecificationsViewer":
        return VesselSpecificationsViewer(self)

    @property
    def WaterwayConditions(self) -> "WaterwayConditionsViewer":
        return WaterwayConditionsViewer(self)



# #########################################################################
# Generated enums 3
# #########################################################################

class NavigationPriorityAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("NavigationPriority")
        self._values: typing.Set[str] = set([  "COST_OPTIMIZATION",  "TIME_CRITICAL",  "RISK_MITIGATION",  "FUEL_EFFICIENCY",  "RELIABILITY",  ])
        self._vals = NavigationPriorityValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "NavigationPriorityValues":
        return self._vals


class NavigationPriorityViewer(NavigationPriorityAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class NavigationPriorityValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def COST_OPTIMIZATION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COST_OPTIMIZATION"))
    
    @property
    def TIME_CRITICAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TIME_CRITICAL"))
    
    @property
    def RISK_MITIGATION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RISK_MITIGATION"))
    
    @property
    def FUEL_EFFICIENCY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FUEL_EFFICIENCY"))
    
    @property
    def RELIABILITY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RELIABILITY"))
    
    


class RiskLevelAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("RiskLevel")
        self._values: typing.Set[str] = set([  "LOW",  "MODERATE",  "HIGH",  "CRITICAL",  ])
        self._vals = RiskLevelValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "RiskLevelValues":
        return self._vals


class RiskLevelViewer(RiskLevelAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class RiskLevelValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def LOW(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LOW"))
    
    @property
    def MODERATE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MODERATE"))
    
    @property
    def HIGH(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HIGH"))
    
    @property
    def CRITICAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CRITICAL"))
    
    


class TransportModeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("TransportMode")
        self._values: typing.Set[str] = set([  "RIVER",  "RAIL",  "TRUCK",  "MULTIMODAL",  ])
        self._vals = TransportModeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "TransportModeValues":
        return self._vals


class TransportModeViewer(TransportModeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class TransportModeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def RIVER(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RIVER"))
    
    @property
    def RAIL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RAIL"))
    
    @property
    def TRUCK(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TRUCK"))
    
    @property
    def MULTIMODAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MULTIMODAL"))
    
    



# #########################################################################
# Generated classes 21
# #########################################################################

class AgriculturePipelineConfigAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AgriculturePipelineConfig")
        self._properties: typing.Set[str] = set([  "ontologies",  "data_sources",  "quality_thresholds",  ])
        self._props = AgriculturePipelineConfigProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AgriculturePipelineConfigProperties":
        return self._props


class AgriculturePipelineConfigViewer(AgriculturePipelineConfigAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AgriculturePipelineConfigProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def ontologies(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("ontologies"))
    
    @property
    def data_sources(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_sources"))
    
    @property
    def quality_thresholds(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("quality_thresholds"))
    
    


class BusinessContextAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("BusinessContext")
        self._properties: typing.Set[str] = set([  "question",  "success_criteria",  "timeline",  "budget",  "risk_tolerance",  "persona_id",  "interaction_level",  ])
        self._props = BusinessContextProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "BusinessContextProperties":
        return self._props


class BusinessContextViewer(BusinessContextAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class BusinessContextProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def question(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("question"))
    
    @property
    def success_criteria(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success_criteria"))
    
    @property
    def timeline(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timeline"))
    
    @property
    def budget(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("budget"))
    
    @property
    def risk_tolerance(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("risk_tolerance"))
    
    @property
    def persona_id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("persona_id"))
    
    @property
    def interaction_level(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("interaction_level"))
    
    


class CongestionAlertAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CongestionAlert")
        self._properties: typing.Set[str] = set([  "location",  "river_mile",  "severity",  "estimated_delay_hours",  "affected_vessels",  "alternative_routes",  "cost_impact_percent",  ])
        self._props = CongestionAlertProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CongestionAlertProperties":
        return self._props


class CongestionAlertViewer(CongestionAlertAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CongestionAlertProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def location(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("location"))
    
    @property
    def river_mile(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("river_mile"))
    
    @property
    def severity(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("severity"))
    
    @property
    def estimated_delay_hours(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("estimated_delay_hours"))
    
    @property
    def affected_vessels(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("affected_vessels"))
    
    @property
    def alternative_routes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("alternative_routes"))
    
    @property
    def cost_impact_percent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cost_impact_percent"))
    
    


class DataContractAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DataContract")
        self._properties: typing.Set[str] = set([  "source_requirements",  "validation_rules",  "transformation_specs",  "quality_thresholds",  "security_requirements",  "compliance_rules",  ])
        self._props = DataContractProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DataContractProperties":
        return self._props


class DataContractViewer(DataContractAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DataContractProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def source_requirements(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source_requirements"))
    
    @property
    def validation_rules(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("validation_rules"))
    
    @property
    def transformation_specs(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transformation_specs"))
    
    @property
    def quality_thresholds(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("quality_thresholds"))
    
    @property
    def security_requirements(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("security_requirements"))
    
    @property
    def compliance_rules(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("compliance_rules"))
    
    


class DataSourceAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DataSource")
        self._properties: typing.Set[str] = set([  "type",  "url",  "authentication_type",  "access_patterns",  "rate_limits",  "documentation_url",  ])
        self._props = DataSourceProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DataSourceProperties":
        return self._props


class DataSourceViewer(DataSourceAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DataSourceProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("url"))
    
    @property
    def authentication_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("authentication_type"))
    
    @property
    def access_patterns(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("access_patterns"))
    
    @property
    def rate_limits(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("rate_limits"))
    
    @property
    def documentation_url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("documentation_url"))
    
    


class DataSourceRecommendationAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DataSourceRecommendation")
        self._properties: typing.Set[str] = set([  "name",  "type",  "description",  "feasibility_score",  "cost_estimate",  "implementation_effort",  "platform_compatibility",  "data_quality_expected",  "access_requirements",  "sample_data_url",  "documentation_url",  "pros",  "cons",  "semantic_vocabularies",  ])
        self._props = DataSourceRecommendationProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DataSourceRecommendationProperties":
        return self._props


class DataSourceRecommendationViewer(DataSourceRecommendationAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DataSourceRecommendationProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def feasibility_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("feasibility_score"))
    
    @property
    def cost_estimate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cost_estimate"))
    
    @property
    def implementation_effort(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("implementation_effort"))
    
    @property
    def platform_compatibility(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("platform_compatibility"))
    
    @property
    def data_quality_expected(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_quality_expected"))
    
    @property
    def access_requirements(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("access_requirements"))
    
    @property
    def sample_data_url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sample_data_url"))
    
    @property
    def documentation_url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("documentation_url"))
    
    @property
    def pros(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pros"))
    
    @property
    def cons(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cons"))
    
    @property
    def semantic_vocabularies(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("semantic_vocabularies"))
    
    


class FeasibilityAnalysisAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FeasibilityAnalysis")
        self._properties: typing.Set[str] = set([  "overall_feasibility",  "technical_risks",  "business_risks",  "mitigation_strategies",  "platform_gaps",  "recommended_alternatives",  "estimated_timeline_weeks",  "confidence_level",  ])
        self._props = FeasibilityAnalysisProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FeasibilityAnalysisProperties":
        return self._props


class FeasibilityAnalysisViewer(FeasibilityAnalysisAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class FeasibilityAnalysisProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def overall_feasibility(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overall_feasibility"))
    
    @property
    def technical_risks(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("technical_risks"))
    
    @property
    def business_risks(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("business_risks"))
    
    @property
    def mitigation_strategies(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("mitigation_strategies"))
    
    @property
    def platform_gaps(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("platform_gaps"))
    
    @property
    def recommended_alternatives(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recommended_alternatives"))
    
    @property
    def estimated_timeline_weeks(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("estimated_timeline_weeks"))
    
    @property
    def confidence_level(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence_level"))
    
    


class GeneratedPipelineAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GeneratedPipeline")
        self._properties: typing.Set[str] = set([  "lambda_code",  "deployment_config",  "monitoring_code",  "validation_code",  "documentation",  "test_cases",  ])
        self._props = GeneratedPipelineProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GeneratedPipelineProperties":
        return self._props


class GeneratedPipelineViewer(GeneratedPipelineAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class GeneratedPipelineProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def lambda_code(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lambda_code"))
    
    @property
    def deployment_config(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("deployment_config"))
    
    @property
    def monitoring_code(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("monitoring_code"))
    
    @property
    def validation_code(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("validation_code"))
    
    @property
    def documentation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("documentation"))
    
    @property
    def test_cases(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("test_cases"))
    
    


class MarketOpportunityAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("MarketOpportunity")
        self._properties: typing.Set[str] = set([  "commodity",  "origin_price",  "destination_price",  "arbitrage_potential",  "transport_cost",  "net_profit_per_ton",  "market_window_days",  "confidence_level",  ])
        self._props = MarketOpportunityProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "MarketOpportunityProperties":
        return self._props


class MarketOpportunityViewer(MarketOpportunityAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class MarketOpportunityProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def commodity(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("commodity"))
    
    @property
    def origin_price(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("origin_price"))
    
    @property
    def destination_price(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("destination_price"))
    
    @property
    def arbitrage_potential(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("arbitrage_potential"))
    
    @property
    def transport_cost(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transport_cost"))
    
    @property
    def net_profit_per_ton(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("net_profit_per_ton"))
    
    @property
    def market_window_days(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("market_window_days"))
    
    @property
    def confidence_level(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence_level"))
    
    


class NavigationRecommendationAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("NavigationRecommendation")
        self._properties: typing.Set[str] = set([  "recommended_route",  "alternative_routes",  "risk_factors",  "cost_analysis",  "timing_considerations",  "weather_alerts",  "market_insights",  "action_items",  "decision_rationale",  ])
        self._props = NavigationRecommendationProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "NavigationRecommendationProperties":
        return self._props


class NavigationRecommendationViewer(NavigationRecommendationAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class NavigationRecommendationProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def recommended_route(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recommended_route"))
    
    @property
    def alternative_routes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("alternative_routes"))
    
    @property
    def risk_factors(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("risk_factors"))
    
    @property
    def cost_analysis(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cost_analysis"))
    
    @property
    def timing_considerations(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timing_considerations"))
    
    @property
    def weather_alerts(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("weather_alerts"))
    
    @property
    def market_insights(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("market_insights"))
    
    @property
    def action_items(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action_items"))
    
    @property
    def decision_rationale(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("decision_rationale"))
    
    


class ParsedDataAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ParsedData")
        self._properties: typing.Set[str] = set([  "format",  "schema",  "quality_score",  "anomalies",  "encoding",  "size_mb",  ])
        self._props = ParsedDataProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ParsedDataProperties":
        return self._props


class ParsedDataViewer(ParsedDataAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ParsedDataProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def format(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("format"))
    
    @property
    def schema(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("schema"))
    
    @property
    def quality_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("quality_score"))
    
    @property
    def anomalies(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("anomalies"))
    
    @property
    def encoding(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("encoding"))
    
    @property
    def size_mb(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("size_mb"))
    
    


class RouteOptionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("RouteOption")
        self._properties: typing.Set[str] = set([  "route_id",  "transport_mode",  "total_distance_miles",  "estimated_travel_time_hours",  "total_cost_usd",  "risk_assessment",  "fuel_cost",  "lock_fees",  "delay_probability",  "confidence_score",  "route_segments",  "alternative_modes",  "cost_breakdown",  ])
        self._props = RouteOptionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "RouteOptionProperties":
        return self._props


class RouteOptionViewer(RouteOptionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class RouteOptionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def route_id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("route_id"))
    
    @property
    def transport_mode(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transport_mode"))
    
    @property
    def total_distance_miles(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total_distance_miles"))
    
    @property
    def estimated_travel_time_hours(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("estimated_travel_time_hours"))
    
    @property
    def total_cost_usd(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total_cost_usd"))
    
    @property
    def risk_assessment(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("risk_assessment"))
    
    @property
    def fuel_cost(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("fuel_cost"))
    
    @property
    def lock_fees(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lock_fees"))
    
    @property
    def delay_probability(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("delay_probability"))
    
    @property
    def confidence_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence_score"))
    
    @property
    def route_segments(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("route_segments"))
    
    @property
    def alternative_modes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("alternative_modes"))
    
    @property
    def cost_breakdown(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cost_breakdown"))
    
    


class RoutingRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("RoutingRequest")
        self._properties: typing.Set[str] = set([  "origin_port",  "destination_port",  "commodity",  "quantity_tons",  "departure_time",  "priority",  "max_delay_hours",  "budget_constraint",  "vessel_specs",  ])
        self._props = RoutingRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "RoutingRequestProperties":
        return self._props


class RoutingRequestViewer(RoutingRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class RoutingRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def origin_port(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("origin_port"))
    
    @property
    def destination_port(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("destination_port"))
    
    @property
    def commodity(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("commodity"))
    
    @property
    def quantity_tons(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("quantity_tons"))
    
    @property
    def departure_time(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("departure_time"))
    
    @property
    def priority(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("priority"))
    
    @property
    def max_delay_hours(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("max_delay_hours"))
    
    @property
    def budget_constraint(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("budget_constraint"))
    
    @property
    def vessel_specs(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("vessel_specs"))
    
    


class SOWContractAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SOWContract")
        self._properties: typing.Set[str] = set([  "project_title",  "executive_summary",  "business_objectives",  "success_metrics",  "data_sources",  "technical_approach",  "deliverables",  "timeline_weeks",  "cost_estimate",  "risk_assessment",  "acceptance_criteria",  "semantic_framework",  ])
        self._props = SOWContractProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SOWContractProperties":
        return self._props


class SOWContractViewer(SOWContractAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SOWContractProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def project_title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("project_title"))
    
    @property
    def executive_summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("executive_summary"))
    
    @property
    def business_objectives(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("business_objectives"))
    
    @property
    def success_metrics(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success_metrics"))
    
    @property
    def data_sources(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_sources"))
    
    @property
    def technical_approach(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("technical_approach"))
    
    @property
    def deliverables(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("deliverables"))
    
    @property
    def timeline_weeks(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timeline_weeks"))
    
    @property
    def cost_estimate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cost_estimate"))
    
    @property
    def risk_assessment(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("risk_assessment"))
    
    @property
    def acceptance_criteria(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("acceptance_criteria"))
    
    @property
    def semantic_framework(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("semantic_framework"))
    
    


class SecurityDecisionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SecurityDecision")
        self._properties: typing.Set[str] = set([  "risk_level",  "decision_required",  "context",  "recommended_action",  "human_approval_needed",  ])
        self._props = SecurityDecisionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SecurityDecisionProperties":
        return self._props


class SecurityDecisionViewer(SecurityDecisionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SecurityDecisionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def risk_level(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("risk_level"))
    
    @property
    def decision_required(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("decision_required"))
    
    @property
    def context(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("context"))
    
    @property
    def recommended_action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recommended_action"))
    
    @property
    def human_approval_needed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("human_approval_needed"))
    
    


class SemanticAnnotationAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SemanticAnnotation")
        self._properties: typing.Set[str] = set([  "ontology_mappings",  "skos_concepts",  "owl_alignments",  "semantic_quality_score",  "domain_coverage",  "linked_entities",  ])
        self._props = SemanticAnnotationProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SemanticAnnotationProperties":
        return self._props


class SemanticAnnotationViewer(SemanticAnnotationAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SemanticAnnotationProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def ontology_mappings(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("ontology_mappings"))
    
    @property
    def skos_concepts(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("skos_concepts"))
    
    @property
    def owl_alignments(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("owl_alignments"))
    
    @property
    def semantic_quality_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("semantic_quality_score"))
    
    @property
    def domain_coverage(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("domain_coverage"))
    
    @property
    def linked_entities(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("linked_entities"))
    
    


class SupplyChainPipelineConfigAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SupplyChainPipelineConfig")
        self._properties: typing.Set[str] = set([  "ontologies",  "data_sources",  "quality_thresholds",  ])
        self._props = SupplyChainPipelineConfigProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SupplyChainPipelineConfigProperties":
        return self._props


class SupplyChainPipelineConfigViewer(SupplyChainPipelineConfigAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SupplyChainPipelineConfigProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def ontologies(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("ontologies"))
    
    @property
    def data_sources(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_sources"))
    
    @property
    def quality_thresholds(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("quality_thresholds"))
    
    


class TradingPipelineConfigAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TradingPipelineConfig")
        self._properties: typing.Set[str] = set([  "ontologies",  "data_sources",  "quality_thresholds",  ])
        self._props = TradingPipelineConfigProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TradingPipelineConfigProperties":
        return self._props


class TradingPipelineConfigViewer(TradingPipelineConfigAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class TradingPipelineConfigProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def ontologies(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("ontologies"))
    
    @property
    def data_sources(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_sources"))
    
    @property
    def quality_thresholds(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("quality_thresholds"))
    
    


class TransformationStrategyAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TransformationStrategy")
        self._properties: typing.Set[str] = set([  "source_schema",  "target_schema",  "transformation_rules",  "validation_logic",  "performance_optimizations",  "error_handling",  ])
        self._props = TransformationStrategyProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TransformationStrategyProperties":
        return self._props


class TransformationStrategyViewer(TransformationStrategyAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class TransformationStrategyProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def source_schema(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source_schema"))
    
    @property
    def target_schema(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("target_schema"))
    
    @property
    def transformation_rules(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transformation_rules"))
    
    @property
    def validation_logic(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("validation_logic"))
    
    @property
    def performance_optimizations(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("performance_optimizations"))
    
    @property
    def error_handling(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error_handling"))
    
    


class VesselSpecificationsAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VesselSpecifications")
        self._properties: typing.Set[str] = set([  "vessel_id",  "vessel_type",  "length",  "width",  "draft",  "cargo_capacity",  "current_load",  "fuel_consumption",  ])
        self._props = VesselSpecificationsProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VesselSpecificationsProperties":
        return self._props


class VesselSpecificationsViewer(VesselSpecificationsAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VesselSpecificationsProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def vessel_id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("vessel_id"))
    
    @property
    def vessel_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("vessel_type"))
    
    @property
    def length(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("length"))
    
    @property
    def width(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("width"))
    
    @property
    def draft(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("draft"))
    
    @property
    def cargo_capacity(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cargo_capacity"))
    
    @property
    def current_load(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("current_load"))
    
    @property
    def fuel_consumption(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("fuel_consumption"))
    
    


class WaterwayConditionsAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("WaterwayConditions")
        self._properties: typing.Set[str] = set([  "water_level",  "flow_rate",  "navigation_status",  "ice_conditions",  "weather_impact",  "lock_delays",  "depth_restrictions",  ])
        self._props = WaterwayConditionsProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "WaterwayConditionsProperties":
        return self._props


class WaterwayConditionsViewer(WaterwayConditionsAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class WaterwayConditionsProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def water_level(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("water_level"))
    
    @property
    def flow_rate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("flow_rate"))
    
    @property
    def navigation_status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("navigation_status"))
    
    @property
    def ice_conditions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("ice_conditions"))
    
    @property
    def weather_impact(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("weather_impact"))
    
    @property
    def lock_delays(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lock_delays"))
    
    @property
    def depth_restrictions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("depth_restrictions"))
    
    

