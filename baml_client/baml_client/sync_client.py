# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
import typing_extensions
import baml_py

from . import stream_types, types, type_builder
from .parser import LlmResponseParser, LlmStreamParser
from .runtime import DoNotUseDirectlyCallManager, BamlCallOptions
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME as __runtime__

class BamlSyncClient:
    __options: DoNotUseDirectlyCallManager
    __stream_client: "BamlStreamClient"
    __http_request: "BamlHttpRequestClient"
    __http_stream_request: "BamlHttpStreamRequestClient"
    __llm_response_parser: LlmResponseParser
    __llm_stream_parser: LlmStreamParser

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options
        self.__stream_client = BamlStreamClient(options)
        self.__http_request = BamlHttpRequestClient(options)
        self.__http_stream_request = BamlHttpStreamRequestClient(options)
        self.__llm_response_parser = LlmResponseParser(options)
        self.__llm_stream_parser = LlmStreamParser(options)

    def __getstate__(self):
        # Return state needed for pickling
        return {"options": self.__options}

    def __setstate__(self, state):
        # Restore state from pickling
        self.__options = state["options"]
        self.__stream_client = BamlStreamClient(self.__options)
        self.__http_request = BamlHttpRequestClient(self.__options)
        self.__http_stream_request = BamlHttpStreamRequestClient(self.__options)
        self.__llm_response_parser = LlmResponseParser(self.__options)
        self.__llm_stream_parser = LlmStreamParser(self.__options)

    def with_options(self,
        tb: typing.Optional[type_builder.TypeBuilder] = None,
        client_registry: typing.Optional[baml_py.baml_py.ClientRegistry] = None,
        collector: typing.Optional[typing.Union[baml_py.baml_py.Collector, typing.List[baml_py.baml_py.Collector]]] = None,
        env: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        on_tick: typing.Optional[typing.Callable[[str, baml_py.baml_py.FunctionLog], None]] = None,
    ) -> "BamlSyncClient":
        options: BamlCallOptions = {}
        if tb is not None:
            options["tb"] = tb
        if client_registry is not None:
            options["client_registry"] = client_registry
        if collector is not None:
            options["collector"] = collector
        if env is not None:
            options["env"] = env
        if on_tick is not None:
            options["on_tick"] = on_tick
        return BamlSyncClient(self.__options.merge_options(options))

    @property
    def stream(self):
      return self.__stream_client

    @property
    def request(self):
      return self.__http_request

    @property
    def stream_request(self):
      return self.__http_stream_request

    @property
    def parse(self):
      return self.__llm_response_parser

    @property
    def parse_stream(self):
      return self.__llm_stream_parser
    
    def AnalyzeNotebookStructure(self, notebook_content: str,
        baml_options: BamlCallOptions = {},
    ) -> types.NotebookStructure:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.AnalyzeNotebookStructure(notebook_content=notebook_content,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="AnalyzeNotebookStructure", args={
                "notebook_content": notebook_content,
            })
            return typing.cast(types.NotebookStructure, result.cast_to(types, types, stream_types, False, __runtime__))
    def AnalyzeSourceFitness(self, source_metadata: types.DataSourceMetadata,business_context: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> typing.Dict[str, str]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.AnalyzeSourceFitness(source_metadata=source_metadata,business_context=business_context,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="AnalyzeSourceFitness", args={
                "source_metadata": source_metadata,"business_context": business_context,
            })
            return typing.cast(typing.Dict[str, str], result.cast_to(types, types, stream_types, False, __runtime__))
    def AnalyzeWorkStreamCoordination(self, theory_artifacts: str,technical_artifacts: str,narrative_artifacts: str,governance_artifacts: str,
        baml_options: BamlCallOptions = {},
    ) -> typing.List["types.ETKLWorkStreamAnalysis"]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.AnalyzeWorkStreamCoordination(theory_artifacts=theory_artifacts,technical_artifacts=technical_artifacts,narrative_artifacts=narrative_artifacts,governance_artifacts=governance_artifacts,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="AnalyzeWorkStreamCoordination", args={
                "theory_artifacts": theory_artifacts,"technical_artifacts": technical_artifacts,"narrative_artifacts": narrative_artifacts,"governance_artifacts": governance_artifacts,
            })
            return typing.cast(typing.List["types.ETKLWorkStreamAnalysis"], result.cast_to(types, types, stream_types, False, __runtime__))
    def BusinessContextAgent(self, business_question: str,success_criteria: str,timeline: str,budget: str,risk_tolerance: str,persona_id: str,
        baml_options: BamlCallOptions = {},
    ) -> types.BusinessContext:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.BusinessContextAgent(business_question=business_question,success_criteria=success_criteria,timeline=timeline,budget=budget,risk_tolerance=risk_tolerance,persona_id=persona_id,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="BusinessContextAgent", args={
                "business_question": business_question,"success_criteria": success_criteria,"timeline": timeline,"budget": budget,"risk_tolerance": risk_tolerance,"persona_id": persona_id,
            })
            return typing.cast(types.BusinessContext, result.cast_to(types, types, stream_types, False, __runtime__))
    def CheckManifestoCompliance(self, work_artifacts: str,manifesto_sections: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> typing.List["types.ETKLManifestoCompliance"]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.CheckManifestoCompliance(work_artifacts=work_artifacts,manifesto_sections=manifesto_sections,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="CheckManifestoCompliance", args={
                "work_artifacts": work_artifacts,"manifesto_sections": manifesto_sections,
            })
            return typing.cast(typing.List["types.ETKLManifestoCompliance"], result.cast_to(types, types, stream_types, False, __runtime__))
    def CongestionManagementAgent(self, current_traffic: typing.Dict[str, int],lock_queues: typing.Dict[str, int],
        baml_options: BamlCallOptions = {},
    ) -> typing.List["types.CongestionAlert"]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.CongestionManagementAgent(current_traffic=current_traffic,lock_queues=lock_queues,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="CongestionManagementAgent", args={
                "current_traffic": current_traffic,"lock_queues": lock_queues,
            })
            return typing.cast(typing.List["types.CongestionAlert"], result.cast_to(types, types, stream_types, False, __runtime__))
    def CreateTargetTemplate(self, target_examples: typing.List[str],enterprise_domain: str,template_name: str,
        baml_options: BamlCallOptions = {},
    ) -> typing.Dict[str, str]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.CreateTargetTemplate(target_examples=target_examples,enterprise_domain=enterprise_domain,template_name=template_name,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="CreateTargetTemplate", args={
                "target_examples": target_examples,"enterprise_domain": enterprise_domain,"template_name": template_name,
            })
            return typing.cast(typing.Dict[str, str], result.cast_to(types, types, stream_types, False, __runtime__))
    def DataFetcherAgent(self, data_sources: typing.List["types.DataSource"],security_requirements: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> str:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.DataFetcherAgent(data_sources=data_sources,security_requirements=security_requirements,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="DataFetcherAgent", args={
                "data_sources": data_sources,"security_requirements": security_requirements,
            })
            return typing.cast(str, result.cast_to(types, types, stream_types, False, __runtime__))
    def DataParserAgent(self, raw_data: str,data_format: str,schema_hints: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> types.ParsedData:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.DataParserAgent(raw_data=raw_data,data_format=data_format,schema_hints=schema_hints,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="DataParserAgent", args={
                "raw_data": raw_data,"data_format": data_format,"schema_hints": schema_hints,
            })
            return typing.cast(types.ParsedData, result.cast_to(types, types, stream_types, False, __runtime__))
    def DataTransformerAgent(self, source_data: types.ParsedData,target_schema: typing.Dict[str, str],business_rules: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> types.TransformationStrategy:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.DataTransformerAgent(source_data=source_data,target_schema=target_schema,business_rules=business_rules,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="DataTransformerAgent", args={
                "source_data": source_data,"target_schema": target_schema,"business_rules": business_rules,
            })
            return typing.cast(types.TransformationStrategy, result.cast_to(types, types, stream_types, False, __runtime__))
    def DecisionSupportAgent(self, current_situation: str,available_options: typing.List["types.RouteOption"],constraints: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> str:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.DecisionSupportAgent(current_situation=current_situation,available_options=available_options,constraints=constraints,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="DecisionSupportAgent", args={
                "current_situation": current_situation,"available_options": available_options,"constraints": constraints,
            })
            return typing.cast(str, result.cast_to(types, types, stream_types, False, __runtime__))
    def DiscoverFromScratch(self, request: types.ZeroStartDiscovery,
        baml_options: BamlCallOptions = {},
    ) -> types.DiscoveryResult:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.DiscoverFromScratch(request=request,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="DiscoverFromScratch", args={
                "request": request,
            })
            return typing.cast(types.DiscoveryResult, result.cast_to(types, types, stream_types, False, __runtime__))
    def DiscoverKnownSources(self, request: types.KnownSourceRequest,
        baml_options: BamlCallOptions = {},
    ) -> typing.List["types.DataSourceMetadata"]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.DiscoverKnownSources(request=request,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="DiscoverKnownSources", args={
                "request": request,
            })
            return typing.cast(typing.List["types.DataSourceMetadata"], result.cast_to(types, types, stream_types, False, __runtime__))
    def ETKLGuruAgent(self, project_artifacts: str,current_work_context: str,proposed_changes: str,
        baml_options: BamlCallOptions = {},
    ) -> types.ETKLVisionAssessment:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.ETKLGuruAgent(project_artifacts=project_artifacts,current_work_context=current_work_context,proposed_changes=proposed_changes,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="ETKLGuruAgent", args={
                "project_artifacts": project_artifacts,"current_work_context": current_work_context,"proposed_changes": proposed_changes,
            })
            return typing.cast(types.ETKLVisionAssessment, result.cast_to(types, types, stream_types, False, __runtime__))
    def EconomicOptimizationAgent(self, market_data: typing.Dict[str, float],transport_rates: typing.Dict[str, float],routing_options: typing.List["types.RouteOption"],
        baml_options: BamlCallOptions = {},
    ) -> typing.List["types.MarketOpportunity"]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.EconomicOptimizationAgent(market_data=market_data,transport_rates=transport_rates,routing_options=routing_options,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="EconomicOptimizationAgent", args={
                "market_data": market_data,"transport_rates": transport_rates,"routing_options": routing_options,
            })
            return typing.cast(typing.List["types.MarketOpportunity"], result.cast_to(types, types, stream_types, False, __runtime__))
    def FeasibilityAnalyzerAgent(self, business_context: types.BusinessContext,recommended_sources: typing.List["types.DataSourceRecommendation"],
        baml_options: BamlCallOptions = {},
    ) -> types.FeasibilityAnalysis:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.FeasibilityAnalyzerAgent(business_context=business_context,recommended_sources=recommended_sources,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="FeasibilityAnalyzerAgent", args={
                "business_context": business_context,"recommended_sources": recommended_sources,
            })
            return typing.cast(types.FeasibilityAnalysis, result.cast_to(types, types, stream_types, False, __runtime__))
    def GenerateAlignmentFeedback(self, target: types.ExecutiveTarget,canvas: types.DataBusinessCanvas,alignment_score: types.AlignmentScore,market_changes: typing.Dict[str, str],progress_data: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> typing.Dict[str, str]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.GenerateAlignmentFeedback(target=target,canvas=canvas,alignment_score=alignment_score,market_changes=market_changes,progress_data=progress_data,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="GenerateAlignmentFeedback", args={
                "target": target,"canvas": canvas,"alignment_score": alignment_score,"market_changes": market_changes,"progress_data": progress_data,
            })
            return typing.cast(typing.Dict[str, str], result.cast_to(types, types, stream_types, False, __runtime__))
    def HydrologicalRiskAgent(self, waterway_segments: typing.List[str],forecast_period_days: int,
        baml_options: BamlCallOptions = {},
    ) -> typing.Dict[str, types.RiskLevel]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.HydrologicalRiskAgent(waterway_segments=waterway_segments,forecast_period_days=forecast_period_days,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="HydrologicalRiskAgent", args={
                "waterway_segments": waterway_segments,"forecast_period_days": forecast_period_days,
            })
            return typing.cast(typing.Dict[str, types.RiskLevel], result.cast_to(types, types, stream_types, False, __runtime__))
    def JupyterStorytellerAgent(self, notebook_content: str,notebook_type: str,target_audience: str,
        baml_options: BamlCallOptions = {},
    ) -> types.StorytellingPlan:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.JupyterStorytellerAgent(notebook_content=notebook_content,notebook_type=notebook_type,target_audience=target_audience,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="JupyterStorytellerAgent", args={
                "notebook_content": notebook_content,"notebook_type": notebook_type,"target_audience": target_audience,
            })
            return typing.cast(types.StorytellingPlan, result.cast_to(types, types, stream_types, False, __runtime__))
    def MultiModalOptimizationAgent(self, origin: str,destination: str,commodity: str,quantity_tons: float,service_requirements: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> typing.List["types.RouteOption"]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.MultiModalOptimizationAgent(origin=origin,destination=destination,commodity=commodity,quantity_tons=quantity_tons,service_requirements=service_requirements,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="MultiModalOptimizationAgent", args={
                "origin": origin,"destination": destination,"commodity": commodity,"quantity_tons": quantity_tons,"service_requirements": service_requirements,
            })
            return typing.cast(typing.List["types.RouteOption"], result.cast_to(types, types, stream_types, False, __runtime__))
    def NavigationIntelligenceAgent(self, routing_request: types.RoutingRequest,current_conditions: types.WaterwayConditions,
        baml_options: BamlCallOptions = {},
    ) -> types.NavigationRecommendation:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.NavigationIntelligenceAgent(routing_request=routing_request,current_conditions=current_conditions,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="NavigationIntelligenceAgent", args={
                "routing_request": routing_request,"current_conditions": current_conditions,
            })
            return typing.cast(types.NavigationRecommendation, result.cast_to(types, types, stream_types, False, __runtime__))
    def OptimizeStoryFlow(self, current_structure: types.NotebookStructure,target_story_type: str,
        baml_options: BamlCallOptions = {},
    ) -> types.StorytellingPlan:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.OptimizeStoryFlow(current_structure=current_structure,target_story_type=target_story_type,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="OptimizeStoryFlow", args={
                "current_structure": current_structure,"target_story_type": target_story_type,
            })
            return typing.cast(types.StorytellingPlan, result.cast_to(types, types, stream_types, False, __runtime__))
    def ParseExecutiveTarget(self, target_description: str,enterprise_context: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> types.TargetParsingResult:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.ParseExecutiveTarget(target_description=target_description,enterprise_context=enterprise_context,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="ParseExecutiveTarget", args={
                "target_description": target_description,"enterprise_context": enterprise_context,
            })
            return typing.cast(types.TargetParsingResult, result.cast_to(types, types, stream_types, False, __runtime__))
    def PersonaResponseAgent(self, base_response: str,persona_id: str,interaction_level: str,technical_depth: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.PersonaResponseAgent(base_response=base_response,persona_id=persona_id,interaction_level=interaction_level,technical_depth=technical_depth,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="PersonaResponseAgent", args={
                "base_response": base_response,"persona_id": persona_id,"interaction_level": interaction_level,"technical_depth": technical_depth,
            })
            return typing.cast(str, result.cast_to(types, types, stream_types, False, __runtime__))
    def PlatformCapabilityAgent(self, data_sources: typing.List[str],requirements: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> typing.Dict[str, float]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.PlatformCapabilityAgent(data_sources=data_sources,requirements=requirements,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="PlatformCapabilityAgent", args={
                "data_sources": data_sources,"requirements": requirements,
            })
            return typing.cast(typing.Dict[str, float], result.cast_to(types, types, stream_types, False, __runtime__))
    def PrepareWorkflowData(self, discovered_sources: typing.List["types.DataSourceMetadata"],canvas_data: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> types.WorkflowPrepopulation:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.PrepareWorkflowData(discovered_sources=discovered_sources,canvas_data=canvas_data,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="PrepareWorkflowData", args={
                "discovered_sources": discovered_sources,"canvas_data": canvas_data,
            })
            return typing.cast(types.WorkflowPrepopulation, result.cast_to(types, types, stream_types, False, __runtime__))
    def SOWGeneratorAgent(self, business_context: types.BusinessContext,selected_sources: typing.List["types.DataSourceRecommendation"],feasibility_analysis: types.FeasibilityAnalysis,
        baml_options: BamlCallOptions = {},
    ) -> types.SOWContract:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.SOWGeneratorAgent(business_context=business_context,selected_sources=selected_sources,feasibility_analysis=feasibility_analysis,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="SOWGeneratorAgent", args={
                "business_context": business_context,"selected_sources": selected_sources,"feasibility_analysis": feasibility_analysis,
            })
            return typing.cast(types.SOWContract, result.cast_to(types, types, stream_types, False, __runtime__))
    def SOWInterpreterAgent(self, sow_document: str,document_format: str,
        baml_options: BamlCallOptions = {},
    ) -> types.DataContract:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.SOWInterpreterAgent(sow_document=sow_document,document_format=document_format,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="SOWInterpreterAgent", args={
                "sow_document": sow_document,"document_format": document_format,
            })
            return typing.cast(types.DataContract, result.cast_to(types, types, stream_types, False, __runtime__))
    def ScoreStrategicAlignment(self, target: types.ExecutiveTarget,canvas: types.DataBusinessCanvas,enterprise_context: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> types.AlignmentScore:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.ScoreStrategicAlignment(target=target,canvas=canvas,enterprise_context=enterprise_context,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="ScoreStrategicAlignment", args={
                "target": target,"canvas": canvas,"enterprise_context": enterprise_context,
            })
            return typing.cast(types.AlignmentScore, result.cast_to(types, types, stream_types, False, __runtime__))
    def SecurityDecisionAgent(self, operation_context: str,risk_assessment: str,data_sensitivity: str,
        baml_options: BamlCallOptions = {},
    ) -> types.SecurityDecision:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.SecurityDecisionAgent(operation_context=operation_context,risk_assessment=risk_assessment,data_sensitivity=data_sensitivity,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="SecurityDecisionAgent", args={
                "operation_context": operation_context,"risk_assessment": risk_assessment,"data_sensitivity": data_sensitivity,
            })
            return typing.cast(types.SecurityDecision, result.cast_to(types, types, stream_types, False, __runtime__))
    def SemanticIntegratorAgent(self, transformed_data: types.ParsedData,business_domain: str,existing_ontologies: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> types.SemanticAnnotation:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.SemanticIntegratorAgent(transformed_data=transformed_data,business_domain=business_domain,existing_ontologies=existing_ontologies,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="SemanticIntegratorAgent", args={
                "transformed_data": transformed_data,"business_domain": business_domain,"existing_ontologies": existing_ontologies,
            })
            return typing.cast(types.SemanticAnnotation, result.cast_to(types, types, stream_types, False, __runtime__))
    def SourceDiscoveryAgent(self, business_context: types.BusinessContext,platform_capabilities: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> typing.List["types.DataSourceRecommendation"]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.SourceDiscoveryAgent(business_context=business_context,platform_capabilities=platform_capabilities,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="SourceDiscoveryAgent", args={
                "business_context": business_context,"platform_capabilities": platform_capabilities,
            })
            return typing.cast(typing.List["types.DataSourceRecommendation"], result.cast_to(types, types, stream_types, False, __runtime__))
    def SupervisorAgent(self, sow_document: str,document_format: str,human_feedback: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> types.GeneratedPipeline:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.SupervisorAgent(sow_document=sow_document,document_format=document_format,human_feedback=human_feedback,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="SupervisorAgent", args={
                "sow_document": sow_document,"document_format": document_format,"human_feedback": human_feedback,
            })
            return typing.cast(types.GeneratedPipeline, result.cast_to(types, types, stream_types, False, __runtime__))
    def ValidateETKLPrinciples(self, work_item: str,work_type: str,
        baml_options: BamlCallOptions = {},
    ) -> typing.List["types.ETKLPrincipleViolation"]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.ValidateETKLPrinciples(work_item=work_item,work_type=work_type,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="ValidateETKLPrinciples", args={
                "work_item": work_item,"work_type": work_type,
            })
            return typing.cast(typing.List["types.ETKLPrincipleViolation"], result.cast_to(types, types, stream_types, False, __runtime__))
    


class BamlStreamClient:
    __options: DoNotUseDirectlyCallManager

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options

    def AnalyzeNotebookStructure(self, notebook_content: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.NotebookStructure, types.NotebookStructure]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="AnalyzeNotebookStructure", args={
            "notebook_content": notebook_content,
        })
        return baml_py.BamlSyncStream[stream_types.NotebookStructure, types.NotebookStructure](
          result,
          lambda x: typing.cast(stream_types.NotebookStructure, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.NotebookStructure, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def AnalyzeSourceFitness(self, source_metadata: types.DataSourceMetadata,business_context: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.Dict[str, str], typing.Dict[str, str]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="AnalyzeSourceFitness", args={
            "source_metadata": source_metadata,"business_context": business_context,
        })
        return baml_py.BamlSyncStream[typing.Dict[str, str], typing.Dict[str, str]](
          result,
          lambda x: typing.cast(typing.Dict[str, str], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.Dict[str, str], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def AnalyzeWorkStreamCoordination(self, theory_artifacts: str,technical_artifacts: str,narrative_artifacts: str,governance_artifacts: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.List["stream_types.ETKLWorkStreamAnalysis"], typing.List["types.ETKLWorkStreamAnalysis"]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="AnalyzeWorkStreamCoordination", args={
            "theory_artifacts": theory_artifacts,"technical_artifacts": technical_artifacts,"narrative_artifacts": narrative_artifacts,"governance_artifacts": governance_artifacts,
        })
        return baml_py.BamlSyncStream[typing.List["stream_types.ETKLWorkStreamAnalysis"], typing.List["types.ETKLWorkStreamAnalysis"]](
          result,
          lambda x: typing.cast(typing.List["stream_types.ETKLWorkStreamAnalysis"], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.List["types.ETKLWorkStreamAnalysis"], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def BusinessContextAgent(self, business_question: str,success_criteria: str,timeline: str,budget: str,risk_tolerance: str,persona_id: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.BusinessContext, types.BusinessContext]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="BusinessContextAgent", args={
            "business_question": business_question,"success_criteria": success_criteria,"timeline": timeline,"budget": budget,"risk_tolerance": risk_tolerance,"persona_id": persona_id,
        })
        return baml_py.BamlSyncStream[stream_types.BusinessContext, types.BusinessContext](
          result,
          lambda x: typing.cast(stream_types.BusinessContext, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.BusinessContext, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def CheckManifestoCompliance(self, work_artifacts: str,manifesto_sections: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.List["stream_types.ETKLManifestoCompliance"], typing.List["types.ETKLManifestoCompliance"]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="CheckManifestoCompliance", args={
            "work_artifacts": work_artifacts,"manifesto_sections": manifesto_sections,
        })
        return baml_py.BamlSyncStream[typing.List["stream_types.ETKLManifestoCompliance"], typing.List["types.ETKLManifestoCompliance"]](
          result,
          lambda x: typing.cast(typing.List["stream_types.ETKLManifestoCompliance"], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.List["types.ETKLManifestoCompliance"], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def CongestionManagementAgent(self, current_traffic: typing.Dict[str, int],lock_queues: typing.Dict[str, int],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.List["stream_types.CongestionAlert"], typing.List["types.CongestionAlert"]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="CongestionManagementAgent", args={
            "current_traffic": current_traffic,"lock_queues": lock_queues,
        })
        return baml_py.BamlSyncStream[typing.List["stream_types.CongestionAlert"], typing.List["types.CongestionAlert"]](
          result,
          lambda x: typing.cast(typing.List["stream_types.CongestionAlert"], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.List["types.CongestionAlert"], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def CreateTargetTemplate(self, target_examples: typing.List[str],enterprise_domain: str,template_name: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.Dict[str, str], typing.Dict[str, str]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="CreateTargetTemplate", args={
            "target_examples": target_examples,"enterprise_domain": enterprise_domain,"template_name": template_name,
        })
        return baml_py.BamlSyncStream[typing.Dict[str, str], typing.Dict[str, str]](
          result,
          lambda x: typing.cast(typing.Dict[str, str], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.Dict[str, str], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def DataFetcherAgent(self, data_sources: typing.List["types.DataSource"],security_requirements: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[str, str]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="DataFetcherAgent", args={
            "data_sources": data_sources,"security_requirements": security_requirements,
        })
        return baml_py.BamlSyncStream[str, str](
          result,
          lambda x: typing.cast(str, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(str, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def DataParserAgent(self, raw_data: str,data_format: str,schema_hints: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.ParsedData, types.ParsedData]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="DataParserAgent", args={
            "raw_data": raw_data,"data_format": data_format,"schema_hints": schema_hints,
        })
        return baml_py.BamlSyncStream[stream_types.ParsedData, types.ParsedData](
          result,
          lambda x: typing.cast(stream_types.ParsedData, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.ParsedData, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def DataTransformerAgent(self, source_data: types.ParsedData,target_schema: typing.Dict[str, str],business_rules: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.TransformationStrategy, types.TransformationStrategy]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="DataTransformerAgent", args={
            "source_data": source_data,"target_schema": target_schema,"business_rules": business_rules,
        })
        return baml_py.BamlSyncStream[stream_types.TransformationStrategy, types.TransformationStrategy](
          result,
          lambda x: typing.cast(stream_types.TransformationStrategy, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.TransformationStrategy, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def DecisionSupportAgent(self, current_situation: str,available_options: typing.List["types.RouteOption"],constraints: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[str, str]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="DecisionSupportAgent", args={
            "current_situation": current_situation,"available_options": available_options,"constraints": constraints,
        })
        return baml_py.BamlSyncStream[str, str](
          result,
          lambda x: typing.cast(str, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(str, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def DiscoverFromScratch(self, request: types.ZeroStartDiscovery,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.DiscoveryResult, types.DiscoveryResult]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="DiscoverFromScratch", args={
            "request": request,
        })
        return baml_py.BamlSyncStream[stream_types.DiscoveryResult, types.DiscoveryResult](
          result,
          lambda x: typing.cast(stream_types.DiscoveryResult, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.DiscoveryResult, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def DiscoverKnownSources(self, request: types.KnownSourceRequest,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.List["stream_types.DataSourceMetadata"], typing.List["types.DataSourceMetadata"]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="DiscoverKnownSources", args={
            "request": request,
        })
        return baml_py.BamlSyncStream[typing.List["stream_types.DataSourceMetadata"], typing.List["types.DataSourceMetadata"]](
          result,
          lambda x: typing.cast(typing.List["stream_types.DataSourceMetadata"], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.List["types.DataSourceMetadata"], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def ETKLGuruAgent(self, project_artifacts: str,current_work_context: str,proposed_changes: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.ETKLVisionAssessment, types.ETKLVisionAssessment]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="ETKLGuruAgent", args={
            "project_artifacts": project_artifacts,"current_work_context": current_work_context,"proposed_changes": proposed_changes,
        })
        return baml_py.BamlSyncStream[stream_types.ETKLVisionAssessment, types.ETKLVisionAssessment](
          result,
          lambda x: typing.cast(stream_types.ETKLVisionAssessment, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.ETKLVisionAssessment, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def EconomicOptimizationAgent(self, market_data: typing.Dict[str, float],transport_rates: typing.Dict[str, float],routing_options: typing.List["types.RouteOption"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.List["stream_types.MarketOpportunity"], typing.List["types.MarketOpportunity"]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="EconomicOptimizationAgent", args={
            "market_data": market_data,"transport_rates": transport_rates,"routing_options": routing_options,
        })
        return baml_py.BamlSyncStream[typing.List["stream_types.MarketOpportunity"], typing.List["types.MarketOpportunity"]](
          result,
          lambda x: typing.cast(typing.List["stream_types.MarketOpportunity"], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.List["types.MarketOpportunity"], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def FeasibilityAnalyzerAgent(self, business_context: types.BusinessContext,recommended_sources: typing.List["types.DataSourceRecommendation"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.FeasibilityAnalysis, types.FeasibilityAnalysis]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="FeasibilityAnalyzerAgent", args={
            "business_context": business_context,"recommended_sources": recommended_sources,
        })
        return baml_py.BamlSyncStream[stream_types.FeasibilityAnalysis, types.FeasibilityAnalysis](
          result,
          lambda x: typing.cast(stream_types.FeasibilityAnalysis, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.FeasibilityAnalysis, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def GenerateAlignmentFeedback(self, target: types.ExecutiveTarget,canvas: types.DataBusinessCanvas,alignment_score: types.AlignmentScore,market_changes: typing.Dict[str, str],progress_data: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.Dict[str, str], typing.Dict[str, str]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="GenerateAlignmentFeedback", args={
            "target": target,"canvas": canvas,"alignment_score": alignment_score,"market_changes": market_changes,"progress_data": progress_data,
        })
        return baml_py.BamlSyncStream[typing.Dict[str, str], typing.Dict[str, str]](
          result,
          lambda x: typing.cast(typing.Dict[str, str], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.Dict[str, str], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def HydrologicalRiskAgent(self, waterway_segments: typing.List[str],forecast_period_days: int,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.Dict[str, types.RiskLevel], typing.Dict[str, types.RiskLevel]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="HydrologicalRiskAgent", args={
            "waterway_segments": waterway_segments,"forecast_period_days": forecast_period_days,
        })
        return baml_py.BamlSyncStream[typing.Dict[str, types.RiskLevel], typing.Dict[str, types.RiskLevel]](
          result,
          lambda x: typing.cast(typing.Dict[str, types.RiskLevel], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.Dict[str, types.RiskLevel], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def JupyterStorytellerAgent(self, notebook_content: str,notebook_type: str,target_audience: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.StorytellingPlan, types.StorytellingPlan]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="JupyterStorytellerAgent", args={
            "notebook_content": notebook_content,"notebook_type": notebook_type,"target_audience": target_audience,
        })
        return baml_py.BamlSyncStream[stream_types.StorytellingPlan, types.StorytellingPlan](
          result,
          lambda x: typing.cast(stream_types.StorytellingPlan, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.StorytellingPlan, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def MultiModalOptimizationAgent(self, origin: str,destination: str,commodity: str,quantity_tons: float,service_requirements: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.List["stream_types.RouteOption"], typing.List["types.RouteOption"]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="MultiModalOptimizationAgent", args={
            "origin": origin,"destination": destination,"commodity": commodity,"quantity_tons": quantity_tons,"service_requirements": service_requirements,
        })
        return baml_py.BamlSyncStream[typing.List["stream_types.RouteOption"], typing.List["types.RouteOption"]](
          result,
          lambda x: typing.cast(typing.List["stream_types.RouteOption"], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.List["types.RouteOption"], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def NavigationIntelligenceAgent(self, routing_request: types.RoutingRequest,current_conditions: types.WaterwayConditions,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.NavigationRecommendation, types.NavigationRecommendation]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="NavigationIntelligenceAgent", args={
            "routing_request": routing_request,"current_conditions": current_conditions,
        })
        return baml_py.BamlSyncStream[stream_types.NavigationRecommendation, types.NavigationRecommendation](
          result,
          lambda x: typing.cast(stream_types.NavigationRecommendation, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.NavigationRecommendation, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def OptimizeStoryFlow(self, current_structure: types.NotebookStructure,target_story_type: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.StorytellingPlan, types.StorytellingPlan]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="OptimizeStoryFlow", args={
            "current_structure": current_structure,"target_story_type": target_story_type,
        })
        return baml_py.BamlSyncStream[stream_types.StorytellingPlan, types.StorytellingPlan](
          result,
          lambda x: typing.cast(stream_types.StorytellingPlan, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.StorytellingPlan, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def ParseExecutiveTarget(self, target_description: str,enterprise_context: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.TargetParsingResult, types.TargetParsingResult]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="ParseExecutiveTarget", args={
            "target_description": target_description,"enterprise_context": enterprise_context,
        })
        return baml_py.BamlSyncStream[stream_types.TargetParsingResult, types.TargetParsingResult](
          result,
          lambda x: typing.cast(stream_types.TargetParsingResult, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.TargetParsingResult, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def PersonaResponseAgent(self, base_response: str,persona_id: str,interaction_level: str,technical_depth: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[str, str]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="PersonaResponseAgent", args={
            "base_response": base_response,"persona_id": persona_id,"interaction_level": interaction_level,"technical_depth": technical_depth,
        })
        return baml_py.BamlSyncStream[str, str](
          result,
          lambda x: typing.cast(str, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(str, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def PlatformCapabilityAgent(self, data_sources: typing.List[str],requirements: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.Dict[str, float], typing.Dict[str, float]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="PlatformCapabilityAgent", args={
            "data_sources": data_sources,"requirements": requirements,
        })
        return baml_py.BamlSyncStream[typing.Dict[str, float], typing.Dict[str, float]](
          result,
          lambda x: typing.cast(typing.Dict[str, float], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.Dict[str, float], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def PrepareWorkflowData(self, discovered_sources: typing.List["types.DataSourceMetadata"],canvas_data: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.WorkflowPrepopulation, types.WorkflowPrepopulation]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="PrepareWorkflowData", args={
            "discovered_sources": discovered_sources,"canvas_data": canvas_data,
        })
        return baml_py.BamlSyncStream[stream_types.WorkflowPrepopulation, types.WorkflowPrepopulation](
          result,
          lambda x: typing.cast(stream_types.WorkflowPrepopulation, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.WorkflowPrepopulation, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def SOWGeneratorAgent(self, business_context: types.BusinessContext,selected_sources: typing.List["types.DataSourceRecommendation"],feasibility_analysis: types.FeasibilityAnalysis,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.SOWContract, types.SOWContract]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="SOWGeneratorAgent", args={
            "business_context": business_context,"selected_sources": selected_sources,"feasibility_analysis": feasibility_analysis,
        })
        return baml_py.BamlSyncStream[stream_types.SOWContract, types.SOWContract](
          result,
          lambda x: typing.cast(stream_types.SOWContract, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.SOWContract, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def SOWInterpreterAgent(self, sow_document: str,document_format: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.DataContract, types.DataContract]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="SOWInterpreterAgent", args={
            "sow_document": sow_document,"document_format": document_format,
        })
        return baml_py.BamlSyncStream[stream_types.DataContract, types.DataContract](
          result,
          lambda x: typing.cast(stream_types.DataContract, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.DataContract, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def ScoreStrategicAlignment(self, target: types.ExecutiveTarget,canvas: types.DataBusinessCanvas,enterprise_context: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.AlignmentScore, types.AlignmentScore]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="ScoreStrategicAlignment", args={
            "target": target,"canvas": canvas,"enterprise_context": enterprise_context,
        })
        return baml_py.BamlSyncStream[stream_types.AlignmentScore, types.AlignmentScore](
          result,
          lambda x: typing.cast(stream_types.AlignmentScore, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.AlignmentScore, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def SecurityDecisionAgent(self, operation_context: str,risk_assessment: str,data_sensitivity: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.SecurityDecision, types.SecurityDecision]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="SecurityDecisionAgent", args={
            "operation_context": operation_context,"risk_assessment": risk_assessment,"data_sensitivity": data_sensitivity,
        })
        return baml_py.BamlSyncStream[stream_types.SecurityDecision, types.SecurityDecision](
          result,
          lambda x: typing.cast(stream_types.SecurityDecision, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.SecurityDecision, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def SemanticIntegratorAgent(self, transformed_data: types.ParsedData,business_domain: str,existing_ontologies: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.SemanticAnnotation, types.SemanticAnnotation]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="SemanticIntegratorAgent", args={
            "transformed_data": transformed_data,"business_domain": business_domain,"existing_ontologies": existing_ontologies,
        })
        return baml_py.BamlSyncStream[stream_types.SemanticAnnotation, types.SemanticAnnotation](
          result,
          lambda x: typing.cast(stream_types.SemanticAnnotation, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.SemanticAnnotation, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def SourceDiscoveryAgent(self, business_context: types.BusinessContext,platform_capabilities: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.List["stream_types.DataSourceRecommendation"], typing.List["types.DataSourceRecommendation"]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="SourceDiscoveryAgent", args={
            "business_context": business_context,"platform_capabilities": platform_capabilities,
        })
        return baml_py.BamlSyncStream[typing.List["stream_types.DataSourceRecommendation"], typing.List["types.DataSourceRecommendation"]](
          result,
          lambda x: typing.cast(typing.List["stream_types.DataSourceRecommendation"], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.List["types.DataSourceRecommendation"], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def SupervisorAgent(self, sow_document: str,document_format: str,human_feedback: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.GeneratedPipeline, types.GeneratedPipeline]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="SupervisorAgent", args={
            "sow_document": sow_document,"document_format": document_format,"human_feedback": human_feedback,
        })
        return baml_py.BamlSyncStream[stream_types.GeneratedPipeline, types.GeneratedPipeline](
          result,
          lambda x: typing.cast(stream_types.GeneratedPipeline, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.GeneratedPipeline, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def ValidateETKLPrinciples(self, work_item: str,work_type: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.List["stream_types.ETKLPrincipleViolation"], typing.List["types.ETKLPrincipleViolation"]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="ValidateETKLPrinciples", args={
            "work_item": work_item,"work_type": work_type,
        })
        return baml_py.BamlSyncStream[typing.List["stream_types.ETKLPrincipleViolation"], typing.List["types.ETKLPrincipleViolation"]](
          result,
          lambda x: typing.cast(typing.List["stream_types.ETKLPrincipleViolation"], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.List["types.ETKLPrincipleViolation"], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    

class BamlHttpRequestClient:
    __options: DoNotUseDirectlyCallManager

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options

    def AnalyzeNotebookStructure(self, notebook_content: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="AnalyzeNotebookStructure", args={
            "notebook_content": notebook_content,
        }, mode="request")
        return result
    def AnalyzeSourceFitness(self, source_metadata: types.DataSourceMetadata,business_context: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="AnalyzeSourceFitness", args={
            "source_metadata": source_metadata,"business_context": business_context,
        }, mode="request")
        return result
    def AnalyzeWorkStreamCoordination(self, theory_artifacts: str,technical_artifacts: str,narrative_artifacts: str,governance_artifacts: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="AnalyzeWorkStreamCoordination", args={
            "theory_artifacts": theory_artifacts,"technical_artifacts": technical_artifacts,"narrative_artifacts": narrative_artifacts,"governance_artifacts": governance_artifacts,
        }, mode="request")
        return result
    def BusinessContextAgent(self, business_question: str,success_criteria: str,timeline: str,budget: str,risk_tolerance: str,persona_id: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="BusinessContextAgent", args={
            "business_question": business_question,"success_criteria": success_criteria,"timeline": timeline,"budget": budget,"risk_tolerance": risk_tolerance,"persona_id": persona_id,
        }, mode="request")
        return result
    def CheckManifestoCompliance(self, work_artifacts: str,manifesto_sections: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="CheckManifestoCompliance", args={
            "work_artifacts": work_artifacts,"manifesto_sections": manifesto_sections,
        }, mode="request")
        return result
    def CongestionManagementAgent(self, current_traffic: typing.Dict[str, int],lock_queues: typing.Dict[str, int],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="CongestionManagementAgent", args={
            "current_traffic": current_traffic,"lock_queues": lock_queues,
        }, mode="request")
        return result
    def CreateTargetTemplate(self, target_examples: typing.List[str],enterprise_domain: str,template_name: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="CreateTargetTemplate", args={
            "target_examples": target_examples,"enterprise_domain": enterprise_domain,"template_name": template_name,
        }, mode="request")
        return result
    def DataFetcherAgent(self, data_sources: typing.List["types.DataSource"],security_requirements: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DataFetcherAgent", args={
            "data_sources": data_sources,"security_requirements": security_requirements,
        }, mode="request")
        return result
    def DataParserAgent(self, raw_data: str,data_format: str,schema_hints: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DataParserAgent", args={
            "raw_data": raw_data,"data_format": data_format,"schema_hints": schema_hints,
        }, mode="request")
        return result
    def DataTransformerAgent(self, source_data: types.ParsedData,target_schema: typing.Dict[str, str],business_rules: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DataTransformerAgent", args={
            "source_data": source_data,"target_schema": target_schema,"business_rules": business_rules,
        }, mode="request")
        return result
    def DecisionSupportAgent(self, current_situation: str,available_options: typing.List["types.RouteOption"],constraints: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DecisionSupportAgent", args={
            "current_situation": current_situation,"available_options": available_options,"constraints": constraints,
        }, mode="request")
        return result
    def DiscoverFromScratch(self, request: types.ZeroStartDiscovery,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DiscoverFromScratch", args={
            "request": request,
        }, mode="request")
        return result
    def DiscoverKnownSources(self, request: types.KnownSourceRequest,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DiscoverKnownSources", args={
            "request": request,
        }, mode="request")
        return result
    def ETKLGuruAgent(self, project_artifacts: str,current_work_context: str,proposed_changes: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="ETKLGuruAgent", args={
            "project_artifacts": project_artifacts,"current_work_context": current_work_context,"proposed_changes": proposed_changes,
        }, mode="request")
        return result
    def EconomicOptimizationAgent(self, market_data: typing.Dict[str, float],transport_rates: typing.Dict[str, float],routing_options: typing.List["types.RouteOption"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="EconomicOptimizationAgent", args={
            "market_data": market_data,"transport_rates": transport_rates,"routing_options": routing_options,
        }, mode="request")
        return result
    def FeasibilityAnalyzerAgent(self, business_context: types.BusinessContext,recommended_sources: typing.List["types.DataSourceRecommendation"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="FeasibilityAnalyzerAgent", args={
            "business_context": business_context,"recommended_sources": recommended_sources,
        }, mode="request")
        return result
    def GenerateAlignmentFeedback(self, target: types.ExecutiveTarget,canvas: types.DataBusinessCanvas,alignment_score: types.AlignmentScore,market_changes: typing.Dict[str, str],progress_data: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="GenerateAlignmentFeedback", args={
            "target": target,"canvas": canvas,"alignment_score": alignment_score,"market_changes": market_changes,"progress_data": progress_data,
        }, mode="request")
        return result
    def HydrologicalRiskAgent(self, waterway_segments: typing.List[str],forecast_period_days: int,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="HydrologicalRiskAgent", args={
            "waterway_segments": waterway_segments,"forecast_period_days": forecast_period_days,
        }, mode="request")
        return result
    def JupyterStorytellerAgent(self, notebook_content: str,notebook_type: str,target_audience: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="JupyterStorytellerAgent", args={
            "notebook_content": notebook_content,"notebook_type": notebook_type,"target_audience": target_audience,
        }, mode="request")
        return result
    def MultiModalOptimizationAgent(self, origin: str,destination: str,commodity: str,quantity_tons: float,service_requirements: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="MultiModalOptimizationAgent", args={
            "origin": origin,"destination": destination,"commodity": commodity,"quantity_tons": quantity_tons,"service_requirements": service_requirements,
        }, mode="request")
        return result
    def NavigationIntelligenceAgent(self, routing_request: types.RoutingRequest,current_conditions: types.WaterwayConditions,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="NavigationIntelligenceAgent", args={
            "routing_request": routing_request,"current_conditions": current_conditions,
        }, mode="request")
        return result
    def OptimizeStoryFlow(self, current_structure: types.NotebookStructure,target_story_type: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="OptimizeStoryFlow", args={
            "current_structure": current_structure,"target_story_type": target_story_type,
        }, mode="request")
        return result
    def ParseExecutiveTarget(self, target_description: str,enterprise_context: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="ParseExecutiveTarget", args={
            "target_description": target_description,"enterprise_context": enterprise_context,
        }, mode="request")
        return result
    def PersonaResponseAgent(self, base_response: str,persona_id: str,interaction_level: str,technical_depth: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="PersonaResponseAgent", args={
            "base_response": base_response,"persona_id": persona_id,"interaction_level": interaction_level,"technical_depth": technical_depth,
        }, mode="request")
        return result
    def PlatformCapabilityAgent(self, data_sources: typing.List[str],requirements: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="PlatformCapabilityAgent", args={
            "data_sources": data_sources,"requirements": requirements,
        }, mode="request")
        return result
    def PrepareWorkflowData(self, discovered_sources: typing.List["types.DataSourceMetadata"],canvas_data: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="PrepareWorkflowData", args={
            "discovered_sources": discovered_sources,"canvas_data": canvas_data,
        }, mode="request")
        return result
    def SOWGeneratorAgent(self, business_context: types.BusinessContext,selected_sources: typing.List["types.DataSourceRecommendation"],feasibility_analysis: types.FeasibilityAnalysis,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SOWGeneratorAgent", args={
            "business_context": business_context,"selected_sources": selected_sources,"feasibility_analysis": feasibility_analysis,
        }, mode="request")
        return result
    def SOWInterpreterAgent(self, sow_document: str,document_format: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SOWInterpreterAgent", args={
            "sow_document": sow_document,"document_format": document_format,
        }, mode="request")
        return result
    def ScoreStrategicAlignment(self, target: types.ExecutiveTarget,canvas: types.DataBusinessCanvas,enterprise_context: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="ScoreStrategicAlignment", args={
            "target": target,"canvas": canvas,"enterprise_context": enterprise_context,
        }, mode="request")
        return result
    def SecurityDecisionAgent(self, operation_context: str,risk_assessment: str,data_sensitivity: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SecurityDecisionAgent", args={
            "operation_context": operation_context,"risk_assessment": risk_assessment,"data_sensitivity": data_sensitivity,
        }, mode="request")
        return result
    def SemanticIntegratorAgent(self, transformed_data: types.ParsedData,business_domain: str,existing_ontologies: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SemanticIntegratorAgent", args={
            "transformed_data": transformed_data,"business_domain": business_domain,"existing_ontologies": existing_ontologies,
        }, mode="request")
        return result
    def SourceDiscoveryAgent(self, business_context: types.BusinessContext,platform_capabilities: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SourceDiscoveryAgent", args={
            "business_context": business_context,"platform_capabilities": platform_capabilities,
        }, mode="request")
        return result
    def SupervisorAgent(self, sow_document: str,document_format: str,human_feedback: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SupervisorAgent", args={
            "sow_document": sow_document,"document_format": document_format,"human_feedback": human_feedback,
        }, mode="request")
        return result
    def ValidateETKLPrinciples(self, work_item: str,work_type: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="ValidateETKLPrinciples", args={
            "work_item": work_item,"work_type": work_type,
        }, mode="request")
        return result
    

class BamlHttpStreamRequestClient:
    __options: DoNotUseDirectlyCallManager

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options

    def AnalyzeNotebookStructure(self, notebook_content: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="AnalyzeNotebookStructure", args={
            "notebook_content": notebook_content,
        }, mode="stream")
        return result
    def AnalyzeSourceFitness(self, source_metadata: types.DataSourceMetadata,business_context: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="AnalyzeSourceFitness", args={
            "source_metadata": source_metadata,"business_context": business_context,
        }, mode="stream")
        return result
    def AnalyzeWorkStreamCoordination(self, theory_artifacts: str,technical_artifacts: str,narrative_artifacts: str,governance_artifacts: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="AnalyzeWorkStreamCoordination", args={
            "theory_artifacts": theory_artifacts,"technical_artifacts": technical_artifacts,"narrative_artifacts": narrative_artifacts,"governance_artifacts": governance_artifacts,
        }, mode="stream")
        return result
    def BusinessContextAgent(self, business_question: str,success_criteria: str,timeline: str,budget: str,risk_tolerance: str,persona_id: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="BusinessContextAgent", args={
            "business_question": business_question,"success_criteria": success_criteria,"timeline": timeline,"budget": budget,"risk_tolerance": risk_tolerance,"persona_id": persona_id,
        }, mode="stream")
        return result
    def CheckManifestoCompliance(self, work_artifacts: str,manifesto_sections: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="CheckManifestoCompliance", args={
            "work_artifacts": work_artifacts,"manifesto_sections": manifesto_sections,
        }, mode="stream")
        return result
    def CongestionManagementAgent(self, current_traffic: typing.Dict[str, int],lock_queues: typing.Dict[str, int],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="CongestionManagementAgent", args={
            "current_traffic": current_traffic,"lock_queues": lock_queues,
        }, mode="stream")
        return result
    def CreateTargetTemplate(self, target_examples: typing.List[str],enterprise_domain: str,template_name: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="CreateTargetTemplate", args={
            "target_examples": target_examples,"enterprise_domain": enterprise_domain,"template_name": template_name,
        }, mode="stream")
        return result
    def DataFetcherAgent(self, data_sources: typing.List["types.DataSource"],security_requirements: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DataFetcherAgent", args={
            "data_sources": data_sources,"security_requirements": security_requirements,
        }, mode="stream")
        return result
    def DataParserAgent(self, raw_data: str,data_format: str,schema_hints: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DataParserAgent", args={
            "raw_data": raw_data,"data_format": data_format,"schema_hints": schema_hints,
        }, mode="stream")
        return result
    def DataTransformerAgent(self, source_data: types.ParsedData,target_schema: typing.Dict[str, str],business_rules: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DataTransformerAgent", args={
            "source_data": source_data,"target_schema": target_schema,"business_rules": business_rules,
        }, mode="stream")
        return result
    def DecisionSupportAgent(self, current_situation: str,available_options: typing.List["types.RouteOption"],constraints: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DecisionSupportAgent", args={
            "current_situation": current_situation,"available_options": available_options,"constraints": constraints,
        }, mode="stream")
        return result
    def DiscoverFromScratch(self, request: types.ZeroStartDiscovery,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DiscoverFromScratch", args={
            "request": request,
        }, mode="stream")
        return result
    def DiscoverKnownSources(self, request: types.KnownSourceRequest,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DiscoverKnownSources", args={
            "request": request,
        }, mode="stream")
        return result
    def ETKLGuruAgent(self, project_artifacts: str,current_work_context: str,proposed_changes: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="ETKLGuruAgent", args={
            "project_artifacts": project_artifacts,"current_work_context": current_work_context,"proposed_changes": proposed_changes,
        }, mode="stream")
        return result
    def EconomicOptimizationAgent(self, market_data: typing.Dict[str, float],transport_rates: typing.Dict[str, float],routing_options: typing.List["types.RouteOption"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="EconomicOptimizationAgent", args={
            "market_data": market_data,"transport_rates": transport_rates,"routing_options": routing_options,
        }, mode="stream")
        return result
    def FeasibilityAnalyzerAgent(self, business_context: types.BusinessContext,recommended_sources: typing.List["types.DataSourceRecommendation"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="FeasibilityAnalyzerAgent", args={
            "business_context": business_context,"recommended_sources": recommended_sources,
        }, mode="stream")
        return result
    def GenerateAlignmentFeedback(self, target: types.ExecutiveTarget,canvas: types.DataBusinessCanvas,alignment_score: types.AlignmentScore,market_changes: typing.Dict[str, str],progress_data: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="GenerateAlignmentFeedback", args={
            "target": target,"canvas": canvas,"alignment_score": alignment_score,"market_changes": market_changes,"progress_data": progress_data,
        }, mode="stream")
        return result
    def HydrologicalRiskAgent(self, waterway_segments: typing.List[str],forecast_period_days: int,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="HydrologicalRiskAgent", args={
            "waterway_segments": waterway_segments,"forecast_period_days": forecast_period_days,
        }, mode="stream")
        return result
    def JupyterStorytellerAgent(self, notebook_content: str,notebook_type: str,target_audience: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="JupyterStorytellerAgent", args={
            "notebook_content": notebook_content,"notebook_type": notebook_type,"target_audience": target_audience,
        }, mode="stream")
        return result
    def MultiModalOptimizationAgent(self, origin: str,destination: str,commodity: str,quantity_tons: float,service_requirements: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="MultiModalOptimizationAgent", args={
            "origin": origin,"destination": destination,"commodity": commodity,"quantity_tons": quantity_tons,"service_requirements": service_requirements,
        }, mode="stream")
        return result
    def NavigationIntelligenceAgent(self, routing_request: types.RoutingRequest,current_conditions: types.WaterwayConditions,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="NavigationIntelligenceAgent", args={
            "routing_request": routing_request,"current_conditions": current_conditions,
        }, mode="stream")
        return result
    def OptimizeStoryFlow(self, current_structure: types.NotebookStructure,target_story_type: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="OptimizeStoryFlow", args={
            "current_structure": current_structure,"target_story_type": target_story_type,
        }, mode="stream")
        return result
    def ParseExecutiveTarget(self, target_description: str,enterprise_context: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="ParseExecutiveTarget", args={
            "target_description": target_description,"enterprise_context": enterprise_context,
        }, mode="stream")
        return result
    def PersonaResponseAgent(self, base_response: str,persona_id: str,interaction_level: str,technical_depth: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="PersonaResponseAgent", args={
            "base_response": base_response,"persona_id": persona_id,"interaction_level": interaction_level,"technical_depth": technical_depth,
        }, mode="stream")
        return result
    def PlatformCapabilityAgent(self, data_sources: typing.List[str],requirements: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="PlatformCapabilityAgent", args={
            "data_sources": data_sources,"requirements": requirements,
        }, mode="stream")
        return result
    def PrepareWorkflowData(self, discovered_sources: typing.List["types.DataSourceMetadata"],canvas_data: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="PrepareWorkflowData", args={
            "discovered_sources": discovered_sources,"canvas_data": canvas_data,
        }, mode="stream")
        return result
    def SOWGeneratorAgent(self, business_context: types.BusinessContext,selected_sources: typing.List["types.DataSourceRecommendation"],feasibility_analysis: types.FeasibilityAnalysis,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SOWGeneratorAgent", args={
            "business_context": business_context,"selected_sources": selected_sources,"feasibility_analysis": feasibility_analysis,
        }, mode="stream")
        return result
    def SOWInterpreterAgent(self, sow_document: str,document_format: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SOWInterpreterAgent", args={
            "sow_document": sow_document,"document_format": document_format,
        }, mode="stream")
        return result
    def ScoreStrategicAlignment(self, target: types.ExecutiveTarget,canvas: types.DataBusinessCanvas,enterprise_context: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="ScoreStrategicAlignment", args={
            "target": target,"canvas": canvas,"enterprise_context": enterprise_context,
        }, mode="stream")
        return result
    def SecurityDecisionAgent(self, operation_context: str,risk_assessment: str,data_sensitivity: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SecurityDecisionAgent", args={
            "operation_context": operation_context,"risk_assessment": risk_assessment,"data_sensitivity": data_sensitivity,
        }, mode="stream")
        return result
    def SemanticIntegratorAgent(self, transformed_data: types.ParsedData,business_domain: str,existing_ontologies: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SemanticIntegratorAgent", args={
            "transformed_data": transformed_data,"business_domain": business_domain,"existing_ontologies": existing_ontologies,
        }, mode="stream")
        return result
    def SourceDiscoveryAgent(self, business_context: types.BusinessContext,platform_capabilities: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SourceDiscoveryAgent", args={
            "business_context": business_context,"platform_capabilities": platform_capabilities,
        }, mode="stream")
        return result
    def SupervisorAgent(self, sow_document: str,document_format: str,human_feedback: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SupervisorAgent", args={
            "sow_document": sow_document,"document_format": document_format,"human_feedback": human_feedback,
        }, mode="stream")
        return result
    def ValidateETKLPrinciples(self, work_item: str,work_type: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="ValidateETKLPrinciples", args={
            "work_item": work_item,"work_type": work_type,
        }, mode="stream")
        return result
    

b = BamlSyncClient(DoNotUseDirectlyCallManager({}))