# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
from baml_py import type_builder
from baml_py import baml_py
# These are exports, not used here, hence the linter is disabled
from baml_py.baml_py import FieldType, EnumValueBuilder, EnumBuilder, ClassBuilder # noqa: F401 # pylint: disable=unused-import
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME

class TypeBuilder(type_builder.TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["AgriculturePipelineConfig","AlignmentScore","BusinessContext","CellMove","CongestionAlert","DataBusinessCanvas","DataContract","DataSource","DataSourceMetadata","DataSourceRecommendation","DiscoveryResult","ETKLCoordinationPlan","ETKLManifestoCompliance","ETKLPrincipleViolation","ETKLVisionAssessment","ETKLWorkStreamAnalysis","ExecutiveTarget","FeasibilityAnalysis","GeneratedPipeline","KnownSourceRequest","MarketOpportunity","NavigationRecommendation","NotebookSection","NotebookStructure","ParsedData","RouteOption","RoutingRequest","SOWContract","SecurityDecision","SemanticAnnotation","StoryArc","StorytellingPlan","SupplyChainPipelineConfig","TargetParsingResult","TradingPipelineConfig","TransformationStrategy","VesselSpecifications","WaterwayConditions","WorkflowPrepopulation","ZeroStartDiscovery",]
        ), enums=set(
          ["DataSourceType","DiscoveryPath","NavigationPriority","RiskLevel","TargetCategory","TargetPriority","TransportMode","UpdateFrequency",]
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)

    # #########################################################################
    # Generated enums 8
    # #########################################################################

    @property
    def DataSourceType(self) -> "DataSourceTypeViewer":
        return DataSourceTypeViewer(self)

    @property
    def DiscoveryPath(self) -> "DiscoveryPathViewer":
        return DiscoveryPathViewer(self)

    @property
    def NavigationPriority(self) -> "NavigationPriorityViewer":
        return NavigationPriorityViewer(self)

    @property
    def RiskLevel(self) -> "RiskLevelViewer":
        return RiskLevelViewer(self)

    @property
    def TargetCategory(self) -> "TargetCategoryViewer":
        return TargetCategoryViewer(self)

    @property
    def TargetPriority(self) -> "TargetPriorityViewer":
        return TargetPriorityViewer(self)

    @property
    def TransportMode(self) -> "TransportModeViewer":
        return TransportModeViewer(self)

    @property
    def UpdateFrequency(self) -> "UpdateFrequencyViewer":
        return UpdateFrequencyViewer(self)


    # #########################################################################
    # Generated classes 40
    # #########################################################################

    @property
    def AgriculturePipelineConfig(self) -> "AgriculturePipelineConfigViewer":
        return AgriculturePipelineConfigViewer(self)

    @property
    def AlignmentScore(self) -> "AlignmentScoreViewer":
        return AlignmentScoreViewer(self)

    @property
    def BusinessContext(self) -> "BusinessContextViewer":
        return BusinessContextViewer(self)

    @property
    def CellMove(self) -> "CellMoveViewer":
        return CellMoveViewer(self)

    @property
    def CongestionAlert(self) -> "CongestionAlertViewer":
        return CongestionAlertViewer(self)

    @property
    def DataBusinessCanvas(self) -> "DataBusinessCanvasViewer":
        return DataBusinessCanvasViewer(self)

    @property
    def DataContract(self) -> "DataContractViewer":
        return DataContractViewer(self)

    @property
    def DataSource(self) -> "DataSourceViewer":
        return DataSourceViewer(self)

    @property
    def DataSourceMetadata(self) -> "DataSourceMetadataViewer":
        return DataSourceMetadataViewer(self)

    @property
    def DataSourceRecommendation(self) -> "DataSourceRecommendationViewer":
        return DataSourceRecommendationViewer(self)

    @property
    def DiscoveryResult(self) -> "DiscoveryResultViewer":
        return DiscoveryResultViewer(self)

    @property
    def ETKLCoordinationPlan(self) -> "ETKLCoordinationPlanViewer":
        return ETKLCoordinationPlanViewer(self)

    @property
    def ETKLManifestoCompliance(self) -> "ETKLManifestoComplianceViewer":
        return ETKLManifestoComplianceViewer(self)

    @property
    def ETKLPrincipleViolation(self) -> "ETKLPrincipleViolationViewer":
        return ETKLPrincipleViolationViewer(self)

    @property
    def ETKLVisionAssessment(self) -> "ETKLVisionAssessmentViewer":
        return ETKLVisionAssessmentViewer(self)

    @property
    def ETKLWorkStreamAnalysis(self) -> "ETKLWorkStreamAnalysisViewer":
        return ETKLWorkStreamAnalysisViewer(self)

    @property
    def ExecutiveTarget(self) -> "ExecutiveTargetViewer":
        return ExecutiveTargetViewer(self)

    @property
    def FeasibilityAnalysis(self) -> "FeasibilityAnalysisViewer":
        return FeasibilityAnalysisViewer(self)

    @property
    def GeneratedPipeline(self) -> "GeneratedPipelineViewer":
        return GeneratedPipelineViewer(self)

    @property
    def KnownSourceRequest(self) -> "KnownSourceRequestViewer":
        return KnownSourceRequestViewer(self)

    @property
    def MarketOpportunity(self) -> "MarketOpportunityViewer":
        return MarketOpportunityViewer(self)

    @property
    def NavigationRecommendation(self) -> "NavigationRecommendationViewer":
        return NavigationRecommendationViewer(self)

    @property
    def NotebookSection(self) -> "NotebookSectionViewer":
        return NotebookSectionViewer(self)

    @property
    def NotebookStructure(self) -> "NotebookStructureViewer":
        return NotebookStructureViewer(self)

    @property
    def ParsedData(self) -> "ParsedDataViewer":
        return ParsedDataViewer(self)

    @property
    def RouteOption(self) -> "RouteOptionViewer":
        return RouteOptionViewer(self)

    @property
    def RoutingRequest(self) -> "RoutingRequestViewer":
        return RoutingRequestViewer(self)

    @property
    def SOWContract(self) -> "SOWContractViewer":
        return SOWContractViewer(self)

    @property
    def SecurityDecision(self) -> "SecurityDecisionViewer":
        return SecurityDecisionViewer(self)

    @property
    def SemanticAnnotation(self) -> "SemanticAnnotationViewer":
        return SemanticAnnotationViewer(self)

    @property
    def StoryArc(self) -> "StoryArcViewer":
        return StoryArcViewer(self)

    @property
    def StorytellingPlan(self) -> "StorytellingPlanViewer":
        return StorytellingPlanViewer(self)

    @property
    def SupplyChainPipelineConfig(self) -> "SupplyChainPipelineConfigViewer":
        return SupplyChainPipelineConfigViewer(self)

    @property
    def TargetParsingResult(self) -> "TargetParsingResultViewer":
        return TargetParsingResultViewer(self)

    @property
    def TradingPipelineConfig(self) -> "TradingPipelineConfigViewer":
        return TradingPipelineConfigViewer(self)

    @property
    def TransformationStrategy(self) -> "TransformationStrategyViewer":
        return TransformationStrategyViewer(self)

    @property
    def VesselSpecifications(self) -> "VesselSpecificationsViewer":
        return VesselSpecificationsViewer(self)

    @property
    def WaterwayConditions(self) -> "WaterwayConditionsViewer":
        return WaterwayConditionsViewer(self)

    @property
    def WorkflowPrepopulation(self) -> "WorkflowPrepopulationViewer":
        return WorkflowPrepopulationViewer(self)

    @property
    def ZeroStartDiscovery(self) -> "ZeroStartDiscoveryViewer":
        return ZeroStartDiscoveryViewer(self)



# #########################################################################
# Generated enums 8
# #########################################################################

class DataSourceTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("DataSourceType")
        self._values: typing.Set[str] = set([  "API",  "DATABASE",  "FILE_SYSTEM",  "WEB_SCRAPING",  "STREAM",  "CLOUD_STORAGE",  ])
        self._vals = DataSourceTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "DataSourceTypeValues":
        return self._vals


class DataSourceTypeViewer(DataSourceTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class DataSourceTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def API(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("API"))
    
    @property
    def DATABASE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DATABASE"))
    
    @property
    def FILE_SYSTEM(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FILE_SYSTEM"))
    
    @property
    def WEB_SCRAPING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("WEB_SCRAPING"))
    
    @property
    def STREAM(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("STREAM"))
    
    @property
    def CLOUD_STORAGE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CLOUD_STORAGE"))
    
    


class DiscoveryPathAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("DiscoveryPath")
        self._values: typing.Set[str] = set([  "KNOWN_SOURCE",  "ZERO_START",  ])
        self._vals = DiscoveryPathValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "DiscoveryPathValues":
        return self._vals


class DiscoveryPathViewer(DiscoveryPathAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class DiscoveryPathValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def KNOWN_SOURCE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("KNOWN_SOURCE"))
    
    @property
    def ZERO_START(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ZERO_START"))
    
    


class NavigationPriorityAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("NavigationPriority")
        self._values: typing.Set[str] = set([  "COST_OPTIMIZATION",  "TIME_CRITICAL",  "RISK_MITIGATION",  "FUEL_EFFICIENCY",  "RELIABILITY",  ])
        self._vals = NavigationPriorityValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "NavigationPriorityValues":
        return self._vals


class NavigationPriorityViewer(NavigationPriorityAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class NavigationPriorityValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def COST_OPTIMIZATION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COST_OPTIMIZATION"))
    
    @property
    def TIME_CRITICAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TIME_CRITICAL"))
    
    @property
    def RISK_MITIGATION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RISK_MITIGATION"))
    
    @property
    def FUEL_EFFICIENCY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FUEL_EFFICIENCY"))
    
    @property
    def RELIABILITY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RELIABILITY"))
    
    


class RiskLevelAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("RiskLevel")
        self._values: typing.Set[str] = set([  "LOW",  "MODERATE",  "HIGH",  "CRITICAL",  ])
        self._vals = RiskLevelValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "RiskLevelValues":
        return self._vals


class RiskLevelViewer(RiskLevelAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class RiskLevelValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def LOW(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LOW"))
    
    @property
    def MODERATE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MODERATE"))
    
    @property
    def HIGH(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HIGH"))
    
    @property
    def CRITICAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CRITICAL"))
    
    


class TargetCategoryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("TargetCategory")
        self._values: typing.Set[str] = set([  "REVENUE",  "MARKET_EXPANSION",  "OPERATIONAL_EFFICIENCY",  "CUSTOMER_EXPERIENCE",  "INNOVATION",  "COMPLIANCE",  "RISK_MANAGEMENT",  "COST_REDUCTION",  "DIGITAL_TRANSFORMATION",  "SUSTAINABILITY",  "TALENT_DEVELOPMENT",  "STRATEGIC_PARTNERSHIP",  ])
        self._vals = TargetCategoryValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "TargetCategoryValues":
        return self._vals


class TargetCategoryViewer(TargetCategoryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class TargetCategoryValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def REVENUE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("REVENUE"))
    
    @property
    def MARKET_EXPANSION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MARKET_EXPANSION"))
    
    @property
    def OPERATIONAL_EFFICIENCY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("OPERATIONAL_EFFICIENCY"))
    
    @property
    def CUSTOMER_EXPERIENCE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CUSTOMER_EXPERIENCE"))
    
    @property
    def INNOVATION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("INNOVATION"))
    
    @property
    def COMPLIANCE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMPLIANCE"))
    
    @property
    def RISK_MANAGEMENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RISK_MANAGEMENT"))
    
    @property
    def COST_REDUCTION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COST_REDUCTION"))
    
    @property
    def DIGITAL_TRANSFORMATION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DIGITAL_TRANSFORMATION"))
    
    @property
    def SUSTAINABILITY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SUSTAINABILITY"))
    
    @property
    def TALENT_DEVELOPMENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TALENT_DEVELOPMENT"))
    
    @property
    def STRATEGIC_PARTNERSHIP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("STRATEGIC_PARTNERSHIP"))
    
    


class TargetPriorityAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("TargetPriority")
        self._values: typing.Set[str] = set([  "CRITICAL",  "HIGH",  "MEDIUM",  "LOW",  ])
        self._vals = TargetPriorityValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "TargetPriorityValues":
        return self._vals


class TargetPriorityViewer(TargetPriorityAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class TargetPriorityValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def CRITICAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CRITICAL"))
    
    @property
    def HIGH(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HIGH"))
    
    @property
    def MEDIUM(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MEDIUM"))
    
    @property
    def LOW(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LOW"))
    
    


class TransportModeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("TransportMode")
        self._values: typing.Set[str] = set([  "RIVER",  "RAIL",  "TRUCK",  "MULTIMODAL",  ])
        self._vals = TransportModeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "TransportModeValues":
        return self._vals


class TransportModeViewer(TransportModeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class TransportModeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def RIVER(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RIVER"))
    
    @property
    def RAIL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RAIL"))
    
    @property
    def TRUCK(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TRUCK"))
    
    @property
    def MULTIMODAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MULTIMODAL"))
    
    


class UpdateFrequencyAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("UpdateFrequency")
        self._values: typing.Set[str] = set([  "REAL_TIME",  "HOURLY",  "DAILY",  "WEEKLY",  "MONTHLY",  "QUARTERLY",  "YEARLY",  "STATIC",  ])
        self._vals = UpdateFrequencyValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "UpdateFrequencyValues":
        return self._vals


class UpdateFrequencyViewer(UpdateFrequencyAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class UpdateFrequencyValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def REAL_TIME(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("REAL_TIME"))
    
    @property
    def HOURLY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HOURLY"))
    
    @property
    def DAILY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DAILY"))
    
    @property
    def WEEKLY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("WEEKLY"))
    
    @property
    def MONTHLY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MONTHLY"))
    
    @property
    def QUARTERLY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("QUARTERLY"))
    
    @property
    def YEARLY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("YEARLY"))
    
    @property
    def STATIC(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("STATIC"))
    
    



# #########################################################################
# Generated classes 40
# #########################################################################

class AgriculturePipelineConfigAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AgriculturePipelineConfig")
        self._properties: typing.Set[str] = set([  "ontologies",  "data_sources",  "quality_thresholds",  ])
        self._props = AgriculturePipelineConfigProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AgriculturePipelineConfigProperties":
        return self._props


class AgriculturePipelineConfigViewer(AgriculturePipelineConfigAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AgriculturePipelineConfigProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def ontologies(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("ontologies"))
    
    @property
    def data_sources(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_sources"))
    
    @property
    def quality_thresholds(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("quality_thresholds"))
    
    


class AlignmentScoreAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AlignmentScore")
        self._properties: typing.Set[str] = set([  "overall_score",  "confidence",  "strategic_fit",  "impact_potential",  "timeline_feasibility",  "resource_efficiency",  "risk_assessment",  "dependency_analysis",  "reasoning",  "key_factors",  "risk_factors",  "recommendations",  ])
        self._props = AlignmentScoreProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AlignmentScoreProperties":
        return self._props


class AlignmentScoreViewer(AlignmentScoreAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AlignmentScoreProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def overall_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overall_score"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    @property
    def strategic_fit(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("strategic_fit"))
    
    @property
    def impact_potential(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("impact_potential"))
    
    @property
    def timeline_feasibility(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timeline_feasibility"))
    
    @property
    def resource_efficiency(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("resource_efficiency"))
    
    @property
    def risk_assessment(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("risk_assessment"))
    
    @property
    def dependency_analysis(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("dependency_analysis"))
    
    @property
    def reasoning(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("reasoning"))
    
    @property
    def key_factors(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("key_factors"))
    
    @property
    def risk_factors(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("risk_factors"))
    
    @property
    def recommendations(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recommendations"))
    
    


class BusinessContextAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("BusinessContext")
        self._properties: typing.Set[str] = set([  "question",  "success_criteria",  "timeline",  "budget",  "risk_tolerance",  "persona_id",  "interaction_level",  ])
        self._props = BusinessContextProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "BusinessContextProperties":
        return self._props


class BusinessContextViewer(BusinessContextAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class BusinessContextProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def question(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("question"))
    
    @property
    def success_criteria(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success_criteria"))
    
    @property
    def timeline(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timeline"))
    
    @property
    def budget(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("budget"))
    
    @property
    def risk_tolerance(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("risk_tolerance"))
    
    @property
    def persona_id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("persona_id"))
    
    @property
    def interaction_level(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("interaction_level"))
    
    


class CellMoveAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CellMove")
        self._properties: typing.Set[str] = set([  "current_position",  "suggested_position",  "reason",  "cell_type",  "content_summary",  ])
        self._props = CellMoveProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CellMoveProperties":
        return self._props


class CellMoveViewer(CellMoveAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CellMoveProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def current_position(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("current_position"))
    
    @property
    def suggested_position(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("suggested_position"))
    
    @property
    def reason(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("reason"))
    
    @property
    def cell_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cell_type"))
    
    @property
    def content_summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content_summary"))
    
    


class CongestionAlertAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CongestionAlert")
        self._properties: typing.Set[str] = set([  "location",  "river_mile",  "severity",  "estimated_delay_hours",  "affected_vessels",  "alternative_routes",  "cost_impact_percent",  ])
        self._props = CongestionAlertProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CongestionAlertProperties":
        return self._props


class CongestionAlertViewer(CongestionAlertAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CongestionAlertProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def location(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("location"))
    
    @property
    def river_mile(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("river_mile"))
    
    @property
    def severity(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("severity"))
    
    @property
    def estimated_delay_hours(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("estimated_delay_hours"))
    
    @property
    def affected_vessels(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("affected_vessels"))
    
    @property
    def alternative_routes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("alternative_routes"))
    
    @property
    def cost_impact_percent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cost_impact_percent"))
    
    


class DataBusinessCanvasAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DataBusinessCanvas")
        self._properties: typing.Set[str] = set([  "value_propositions",  "key_activities",  "key_resources",  "key_partnerships",  "customer_segments",  "customer_relationships",  "channels",  "cost_structure",  "revenue_streams",  "data_assets",  "intelligence_capabilities",  "competitive_advantages",  "business_domain",  "use_case_description",  "timeline",  "budget",  ])
        self._props = DataBusinessCanvasProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DataBusinessCanvasProperties":
        return self._props


class DataBusinessCanvasViewer(DataBusinessCanvasAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DataBusinessCanvasProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def value_propositions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("value_propositions"))
    
    @property
    def key_activities(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("key_activities"))
    
    @property
    def key_resources(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("key_resources"))
    
    @property
    def key_partnerships(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("key_partnerships"))
    
    @property
    def customer_segments(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("customer_segments"))
    
    @property
    def customer_relationships(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("customer_relationships"))
    
    @property
    def channels(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("channels"))
    
    @property
    def cost_structure(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cost_structure"))
    
    @property
    def revenue_streams(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("revenue_streams"))
    
    @property
    def data_assets(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_assets"))
    
    @property
    def intelligence_capabilities(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("intelligence_capabilities"))
    
    @property
    def competitive_advantages(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("competitive_advantages"))
    
    @property
    def business_domain(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("business_domain"))
    
    @property
    def use_case_description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("use_case_description"))
    
    @property
    def timeline(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timeline"))
    
    @property
    def budget(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("budget"))
    
    


class DataContractAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DataContract")
        self._properties: typing.Set[str] = set([  "source_requirements",  "validation_rules",  "transformation_specs",  "quality_thresholds",  "security_requirements",  "compliance_rules",  ])
        self._props = DataContractProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DataContractProperties":
        return self._props


class DataContractViewer(DataContractAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DataContractProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def source_requirements(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source_requirements"))
    
    @property
    def validation_rules(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("validation_rules"))
    
    @property
    def transformation_specs(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transformation_specs"))
    
    @property
    def quality_thresholds(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("quality_thresholds"))
    
    @property
    def security_requirements(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("security_requirements"))
    
    @property
    def compliance_rules(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("compliance_rules"))
    
    


class DataSourceAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DataSource")
        self._properties: typing.Set[str] = set([  "type",  "url",  "authentication_type",  "access_patterns",  "rate_limits",  "documentation_url",  ])
        self._props = DataSourceProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DataSourceProperties":
        return self._props


class DataSourceViewer(DataSourceAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DataSourceProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("url"))
    
    @property
    def authentication_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("authentication_type"))
    
    @property
    def access_patterns(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("access_patterns"))
    
    @property
    def rate_limits(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("rate_limits"))
    
    @property
    def documentation_url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("documentation_url"))
    
    


class DataSourceMetadataAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DataSourceMetadata")
        self._properties: typing.Set[str] = set([  "name",  "url",  "description",  "source_type",  "access_method",  "authentication_required",  "authentication_method",  "rate_limits",  "data_formats",  "schema_available",  "schema_url",  "sample_data_url",  "data_volume_estimate",  "update_frequency",  "historical_data_available",  "historical_range",  "data_quality_score",  "completeness_estimate",  "accuracy_indicators",  "known_data_issues",  "license_type",  "terms_of_use_url",  "privacy_considerations",  "compliance_standards",  "relevance_score",  "business_domains",  "use_cases",  "discovery_method",  "confidence_score",  ])
        self._props = DataSourceMetadataProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DataSourceMetadataProperties":
        return self._props


class DataSourceMetadataViewer(DataSourceMetadataAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DataSourceMetadataProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("url"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def source_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source_type"))
    
    @property
    def access_method(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("access_method"))
    
    @property
    def authentication_required(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("authentication_required"))
    
    @property
    def authentication_method(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("authentication_method"))
    
    @property
    def rate_limits(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("rate_limits"))
    
    @property
    def data_formats(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_formats"))
    
    @property
    def schema_available(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("schema_available"))
    
    @property
    def schema_url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("schema_url"))
    
    @property
    def sample_data_url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sample_data_url"))
    
    @property
    def data_volume_estimate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_volume_estimate"))
    
    @property
    def update_frequency(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("update_frequency"))
    
    @property
    def historical_data_available(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("historical_data_available"))
    
    @property
    def historical_range(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("historical_range"))
    
    @property
    def data_quality_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_quality_score"))
    
    @property
    def completeness_estimate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("completeness_estimate"))
    
    @property
    def accuracy_indicators(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("accuracy_indicators"))
    
    @property
    def known_data_issues(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("known_data_issues"))
    
    @property
    def license_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("license_type"))
    
    @property
    def terms_of_use_url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("terms_of_use_url"))
    
    @property
    def privacy_considerations(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("privacy_considerations"))
    
    @property
    def compliance_standards(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("compliance_standards"))
    
    @property
    def relevance_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("relevance_score"))
    
    @property
    def business_domains(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("business_domains"))
    
    @property
    def use_cases(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("use_cases"))
    
    @property
    def discovery_method(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("discovery_method"))
    
    @property
    def confidence_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence_score"))
    
    


class DataSourceRecommendationAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DataSourceRecommendation")
        self._properties: typing.Set[str] = set([  "name",  "type",  "description",  "feasibility_score",  "cost_estimate",  "implementation_effort",  "platform_compatibility",  "data_quality_expected",  "access_requirements",  "sample_data_url",  "documentation_url",  "pros",  "cons",  "semantic_vocabularies",  ])
        self._props = DataSourceRecommendationProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DataSourceRecommendationProperties":
        return self._props


class DataSourceRecommendationViewer(DataSourceRecommendationAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DataSourceRecommendationProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def feasibility_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("feasibility_score"))
    
    @property
    def cost_estimate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cost_estimate"))
    
    @property
    def implementation_effort(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("implementation_effort"))
    
    @property
    def platform_compatibility(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("platform_compatibility"))
    
    @property
    def data_quality_expected(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_quality_expected"))
    
    @property
    def access_requirements(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("access_requirements"))
    
    @property
    def sample_data_url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sample_data_url"))
    
    @property
    def documentation_url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("documentation_url"))
    
    @property
    def pros(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pros"))
    
    @property
    def cons(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cons"))
    
    @property
    def semantic_vocabularies(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("semantic_vocabularies"))
    
    


class DiscoveryResultAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DiscoveryResult")
        self._properties: typing.Set[str] = set([  "discovery_path",  "discovered_sources",  "total_sources_found",  "search_queries_used",  "discovery_duration_seconds",  "recommended_next_steps",  "prefilled_operations_data",  "prefilled_governance_data",  ])
        self._props = DiscoveryResultProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DiscoveryResultProperties":
        return self._props


class DiscoveryResultViewer(DiscoveryResultAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DiscoveryResultProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def discovery_path(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("discovery_path"))
    
    @property
    def discovered_sources(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("discovered_sources"))
    
    @property
    def total_sources_found(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total_sources_found"))
    
    @property
    def search_queries_used(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("search_queries_used"))
    
    @property
    def discovery_duration_seconds(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("discovery_duration_seconds"))
    
    @property
    def recommended_next_steps(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recommended_next_steps"))
    
    @property
    def prefilled_operations_data(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("prefilled_operations_data"))
    
    @property
    def prefilled_governance_data(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("prefilled_governance_data"))
    
    


class ETKLCoordinationPlanAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ETKLCoordinationPlan")
        self._properties: typing.Set[str] = set([  "coordination_strategy",  "work_stream_priorities",  "critical_dependencies",  "synchronization_points",  "quality_gates",  "escalation_triggers",  "success_metrics",  ])
        self._props = ETKLCoordinationPlanProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ETKLCoordinationPlanProperties":
        return self._props


class ETKLCoordinationPlanViewer(ETKLCoordinationPlanAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ETKLCoordinationPlanProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def coordination_strategy(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coordination_strategy"))
    
    @property
    def work_stream_priorities(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("work_stream_priorities"))
    
    @property
    def critical_dependencies(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("critical_dependencies"))
    
    @property
    def synchronization_points(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("synchronization_points"))
    
    @property
    def quality_gates(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("quality_gates"))
    
    @property
    def escalation_triggers(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("escalation_triggers"))
    
    @property
    def success_metrics(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success_metrics"))
    
    


class ETKLManifestoComplianceAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ETKLManifestoCompliance")
        self._properties: typing.Set[str] = set([  "manifesto_section",  "compliance_level",  "evidence",  "gaps",  "recommendations",  ])
        self._props = ETKLManifestoComplianceProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ETKLManifestoComplianceProperties":
        return self._props


class ETKLManifestoComplianceViewer(ETKLManifestoComplianceAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ETKLManifestoComplianceProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def manifesto_section(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("manifesto_section"))
    
    @property
    def compliance_level(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("compliance_level"))
    
    @property
    def evidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("evidence"))
    
    @property
    def gaps(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("gaps"))
    
    @property
    def recommendations(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recommendations"))
    
    


class ETKLPrincipleViolationAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ETKLPrincipleViolation")
        self._properties: typing.Set[str] = set([  "principle_violated",  "severity",  "location",  "description",  "business_impact",  "corrective_action",  "priority",  ])
        self._props = ETKLPrincipleViolationProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ETKLPrincipleViolationProperties":
        return self._props


class ETKLPrincipleViolationViewer(ETKLPrincipleViolationAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ETKLPrincipleViolationProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def principle_violated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("principle_violated"))
    
    @property
    def severity(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("severity"))
    
    @property
    def location(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("location"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def business_impact(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("business_impact"))
    
    @property
    def corrective_action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("corrective_action"))
    
    @property
    def priority(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("priority"))
    
    


class ETKLVisionAssessmentAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ETKLVisionAssessment")
        self._properties: typing.Set[str] = set([  "overall_alignment_score",  "theoretical_consistency",  "technical_implementation",  "narrative_coherence",  "governance_compliance",  "critical_gaps",  "misalignment_risks",  "recommended_actions",  ])
        self._props = ETKLVisionAssessmentProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ETKLVisionAssessmentProperties":
        return self._props


class ETKLVisionAssessmentViewer(ETKLVisionAssessmentAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ETKLVisionAssessmentProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def overall_alignment_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overall_alignment_score"))
    
    @property
    def theoretical_consistency(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("theoretical_consistency"))
    
    @property
    def technical_implementation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("technical_implementation"))
    
    @property
    def narrative_coherence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("narrative_coherence"))
    
    @property
    def governance_compliance(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("governance_compliance"))
    
    @property
    def critical_gaps(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("critical_gaps"))
    
    @property
    def misalignment_risks(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("misalignment_risks"))
    
    @property
    def recommended_actions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recommended_actions"))
    
    


class ETKLWorkStreamAnalysisAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ETKLWorkStreamAnalysis")
        self._properties: typing.Set[str] = set([  "work_stream",  "current_state",  "target_state",  "alignment_score",  "key_deliverables",  "dependencies",  "risks",  "next_actions",  ])
        self._props = ETKLWorkStreamAnalysisProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ETKLWorkStreamAnalysisProperties":
        return self._props


class ETKLWorkStreamAnalysisViewer(ETKLWorkStreamAnalysisAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ETKLWorkStreamAnalysisProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def work_stream(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("work_stream"))
    
    @property
    def current_state(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("current_state"))
    
    @property
    def target_state(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("target_state"))
    
    @property
    def alignment_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("alignment_score"))
    
    @property
    def key_deliverables(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("key_deliverables"))
    
    @property
    def dependencies(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("dependencies"))
    
    @property
    def risks(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("risks"))
    
    @property
    def next_actions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("next_actions"))
    
    


class ExecutiveTargetAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ExecutiveTarget")
        self._properties: typing.Set[str] = set([  "id",  "title",  "description",  "category",  "priority",  "owner",  "owner_role",  "deadline",  "success_metrics",  "target_value",  "baseline_value",  "business_domain",  "stakeholders",  "dependencies",  "constraints",  "status",  ])
        self._props = ExecutiveTargetProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ExecutiveTargetProperties":
        return self._props


class ExecutiveTargetViewer(ExecutiveTargetAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ExecutiveTargetProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def category(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("category"))
    
    @property
    def priority(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("priority"))
    
    @property
    def owner(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("owner"))
    
    @property
    def owner_role(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("owner_role"))
    
    @property
    def deadline(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("deadline"))
    
    @property
    def success_metrics(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success_metrics"))
    
    @property
    def target_value(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("target_value"))
    
    @property
    def baseline_value(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("baseline_value"))
    
    @property
    def business_domain(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("business_domain"))
    
    @property
    def stakeholders(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("stakeholders"))
    
    @property
    def dependencies(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("dependencies"))
    
    @property
    def constraints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("constraints"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    


class FeasibilityAnalysisAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FeasibilityAnalysis")
        self._properties: typing.Set[str] = set([  "overall_feasibility",  "technical_risks",  "business_risks",  "mitigation_strategies",  "platform_gaps",  "recommended_alternatives",  "estimated_timeline_weeks",  "confidence_level",  ])
        self._props = FeasibilityAnalysisProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FeasibilityAnalysisProperties":
        return self._props


class FeasibilityAnalysisViewer(FeasibilityAnalysisAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class FeasibilityAnalysisProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def overall_feasibility(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overall_feasibility"))
    
    @property
    def technical_risks(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("technical_risks"))
    
    @property
    def business_risks(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("business_risks"))
    
    @property
    def mitigation_strategies(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("mitigation_strategies"))
    
    @property
    def platform_gaps(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("platform_gaps"))
    
    @property
    def recommended_alternatives(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recommended_alternatives"))
    
    @property
    def estimated_timeline_weeks(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("estimated_timeline_weeks"))
    
    @property
    def confidence_level(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence_level"))
    
    


class GeneratedPipelineAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GeneratedPipeline")
        self._properties: typing.Set[str] = set([  "lambda_code",  "deployment_config",  "monitoring_code",  "validation_code",  "documentation",  "test_cases",  ])
        self._props = GeneratedPipelineProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GeneratedPipelineProperties":
        return self._props


class GeneratedPipelineViewer(GeneratedPipelineAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class GeneratedPipelineProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def lambda_code(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lambda_code"))
    
    @property
    def deployment_config(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("deployment_config"))
    
    @property
    def monitoring_code(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("monitoring_code"))
    
    @property
    def validation_code(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("validation_code"))
    
    @property
    def documentation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("documentation"))
    
    @property
    def test_cases(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("test_cases"))
    
    


class KnownSourceRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("KnownSourceRequest")
        self._properties: typing.Set[str] = set([  "source_urls",  "expected_source_type",  "specific_datasets",  "collection_depth",  ])
        self._props = KnownSourceRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "KnownSourceRequestProperties":
        return self._props


class KnownSourceRequestViewer(KnownSourceRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class KnownSourceRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def source_urls(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source_urls"))
    
    @property
    def expected_source_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("expected_source_type"))
    
    @property
    def specific_datasets(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("specific_datasets"))
    
    @property
    def collection_depth(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("collection_depth"))
    
    


class MarketOpportunityAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("MarketOpportunity")
        self._properties: typing.Set[str] = set([  "commodity",  "origin_price",  "destination_price",  "arbitrage_potential",  "transport_cost",  "net_profit_per_ton",  "market_window_days",  "confidence_level",  ])
        self._props = MarketOpportunityProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "MarketOpportunityProperties":
        return self._props


class MarketOpportunityViewer(MarketOpportunityAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class MarketOpportunityProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def commodity(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("commodity"))
    
    @property
    def origin_price(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("origin_price"))
    
    @property
    def destination_price(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("destination_price"))
    
    @property
    def arbitrage_potential(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("arbitrage_potential"))
    
    @property
    def transport_cost(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transport_cost"))
    
    @property
    def net_profit_per_ton(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("net_profit_per_ton"))
    
    @property
    def market_window_days(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("market_window_days"))
    
    @property
    def confidence_level(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence_level"))
    
    


class NavigationRecommendationAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("NavigationRecommendation")
        self._properties: typing.Set[str] = set([  "recommended_route",  "alternative_routes",  "risk_factors",  "cost_analysis",  "timing_considerations",  "weather_alerts",  "market_insights",  "action_items",  "decision_rationale",  ])
        self._props = NavigationRecommendationProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "NavigationRecommendationProperties":
        return self._props


class NavigationRecommendationViewer(NavigationRecommendationAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class NavigationRecommendationProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def recommended_route(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recommended_route"))
    
    @property
    def alternative_routes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("alternative_routes"))
    
    @property
    def risk_factors(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("risk_factors"))
    
    @property
    def cost_analysis(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cost_analysis"))
    
    @property
    def timing_considerations(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timing_considerations"))
    
    @property
    def weather_alerts(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("weather_alerts"))
    
    @property
    def market_insights(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("market_insights"))
    
    @property
    def action_items(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action_items"))
    
    @property
    def decision_rationale(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("decision_rationale"))
    
    


class NotebookSectionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("NotebookSection")
        self._properties: typing.Set[str] = set([  "section_name",  "cell_range",  "cell_types",  "purpose",  "story_function",  "narrative_quality",  "issues",  "suggestions",  ])
        self._props = NotebookSectionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "NotebookSectionProperties":
        return self._props


class NotebookSectionViewer(NotebookSectionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class NotebookSectionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def section_name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("section_name"))
    
    @property
    def cell_range(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cell_range"))
    
    @property
    def cell_types(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cell_types"))
    
    @property
    def purpose(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("purpose"))
    
    @property
    def story_function(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("story_function"))
    
    @property
    def narrative_quality(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("narrative_quality"))
    
    @property
    def issues(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("issues"))
    
    @property
    def suggestions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("suggestions"))
    
    


class NotebookStructureAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("NotebookStructure")
        self._properties: typing.Set[str] = set([  "title",  "sections",  "total_cells",  "story_flow_score",  "narrative_issues",  "improvement_suggestions",  ])
        self._props = NotebookStructureProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "NotebookStructureProperties":
        return self._props


class NotebookStructureViewer(NotebookStructureAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class NotebookStructureProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def sections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sections"))
    
    @property
    def total_cells(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total_cells"))
    
    @property
    def story_flow_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("story_flow_score"))
    
    @property
    def narrative_issues(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("narrative_issues"))
    
    @property
    def improvement_suggestions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("improvement_suggestions"))
    
    


class ParsedDataAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ParsedData")
        self._properties: typing.Set[str] = set([  "format",  "schema",  "quality_score",  "anomalies",  "encoding",  "size_mb",  ])
        self._props = ParsedDataProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ParsedDataProperties":
        return self._props


class ParsedDataViewer(ParsedDataAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ParsedDataProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def format(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("format"))
    
    @property
    def schema(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("schema"))
    
    @property
    def quality_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("quality_score"))
    
    @property
    def anomalies(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("anomalies"))
    
    @property
    def encoding(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("encoding"))
    
    @property
    def size_mb(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("size_mb"))
    
    


class RouteOptionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("RouteOption")
        self._properties: typing.Set[str] = set([  "route_id",  "transport_mode",  "total_distance_miles",  "estimated_travel_time_hours",  "total_cost_usd",  "risk_assessment",  "fuel_cost",  "lock_fees",  "delay_probability",  "confidence_score",  "route_segments",  "alternative_modes",  "cost_breakdown",  ])
        self._props = RouteOptionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "RouteOptionProperties":
        return self._props


class RouteOptionViewer(RouteOptionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class RouteOptionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def route_id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("route_id"))
    
    @property
    def transport_mode(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transport_mode"))
    
    @property
    def total_distance_miles(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total_distance_miles"))
    
    @property
    def estimated_travel_time_hours(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("estimated_travel_time_hours"))
    
    @property
    def total_cost_usd(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total_cost_usd"))
    
    @property
    def risk_assessment(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("risk_assessment"))
    
    @property
    def fuel_cost(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("fuel_cost"))
    
    @property
    def lock_fees(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lock_fees"))
    
    @property
    def delay_probability(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("delay_probability"))
    
    @property
    def confidence_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence_score"))
    
    @property
    def route_segments(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("route_segments"))
    
    @property
    def alternative_modes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("alternative_modes"))
    
    @property
    def cost_breakdown(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cost_breakdown"))
    
    


class RoutingRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("RoutingRequest")
        self._properties: typing.Set[str] = set([  "origin_port",  "destination_port",  "commodity",  "quantity_tons",  "departure_time",  "priority",  "max_delay_hours",  "budget_constraint",  "vessel_specs",  ])
        self._props = RoutingRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "RoutingRequestProperties":
        return self._props


class RoutingRequestViewer(RoutingRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class RoutingRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def origin_port(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("origin_port"))
    
    @property
    def destination_port(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("destination_port"))
    
    @property
    def commodity(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("commodity"))
    
    @property
    def quantity_tons(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("quantity_tons"))
    
    @property
    def departure_time(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("departure_time"))
    
    @property
    def priority(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("priority"))
    
    @property
    def max_delay_hours(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("max_delay_hours"))
    
    @property
    def budget_constraint(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("budget_constraint"))
    
    @property
    def vessel_specs(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("vessel_specs"))
    
    


class SOWContractAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SOWContract")
        self._properties: typing.Set[str] = set([  "project_title",  "executive_summary",  "business_objectives",  "success_metrics",  "data_sources",  "technical_approach",  "deliverables",  "timeline_weeks",  "cost_estimate",  "risk_assessment",  "acceptance_criteria",  "semantic_framework",  ])
        self._props = SOWContractProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SOWContractProperties":
        return self._props


class SOWContractViewer(SOWContractAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SOWContractProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def project_title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("project_title"))
    
    @property
    def executive_summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("executive_summary"))
    
    @property
    def business_objectives(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("business_objectives"))
    
    @property
    def success_metrics(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success_metrics"))
    
    @property
    def data_sources(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_sources"))
    
    @property
    def technical_approach(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("technical_approach"))
    
    @property
    def deliverables(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("deliverables"))
    
    @property
    def timeline_weeks(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timeline_weeks"))
    
    @property
    def cost_estimate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cost_estimate"))
    
    @property
    def risk_assessment(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("risk_assessment"))
    
    @property
    def acceptance_criteria(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("acceptance_criteria"))
    
    @property
    def semantic_framework(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("semantic_framework"))
    
    


class SecurityDecisionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SecurityDecision")
        self._properties: typing.Set[str] = set([  "risk_level",  "decision_required",  "context",  "recommended_action",  "human_approval_needed",  ])
        self._props = SecurityDecisionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SecurityDecisionProperties":
        return self._props


class SecurityDecisionViewer(SecurityDecisionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SecurityDecisionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def risk_level(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("risk_level"))
    
    @property
    def decision_required(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("decision_required"))
    
    @property
    def context(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("context"))
    
    @property
    def recommended_action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recommended_action"))
    
    @property
    def human_approval_needed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("human_approval_needed"))
    
    


class SemanticAnnotationAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SemanticAnnotation")
        self._properties: typing.Set[str] = set([  "ontology_mappings",  "skos_concepts",  "owl_alignments",  "semantic_quality_score",  "domain_coverage",  "linked_entities",  ])
        self._props = SemanticAnnotationProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SemanticAnnotationProperties":
        return self._props


class SemanticAnnotationViewer(SemanticAnnotationAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SemanticAnnotationProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def ontology_mappings(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("ontology_mappings"))
    
    @property
    def skos_concepts(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("skos_concepts"))
    
    @property
    def owl_alignments(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("owl_alignments"))
    
    @property
    def semantic_quality_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("semantic_quality_score"))
    
    @property
    def domain_coverage(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("domain_coverage"))
    
    @property
    def linked_entities(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("linked_entities"))
    
    


class StoryArcAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StoryArc")
        self._properties: typing.Set[str] = set([  "phase",  "description",  "cells_needed",  "current_status",  "improvement_actions",  ])
        self._props = StoryArcProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StoryArcProperties":
        return self._props


class StoryArcViewer(StoryArcAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class StoryArcProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def phase(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("phase"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def cells_needed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cells_needed"))
    
    @property
    def current_status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("current_status"))
    
    @property
    def improvement_actions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("improvement_actions"))
    
    


class StorytellingPlanAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StorytellingPlan")
        self._properties: typing.Set[str] = set([  "narrative_theme",  "target_audience",  "learning_objectives",  "story_arc",  "cell_reorganization",  "missing_elements",  "recommended_flow",  ])
        self._props = StorytellingPlanProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StorytellingPlanProperties":
        return self._props


class StorytellingPlanViewer(StorytellingPlanAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class StorytellingPlanProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def narrative_theme(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("narrative_theme"))
    
    @property
    def target_audience(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("target_audience"))
    
    @property
    def learning_objectives(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("learning_objectives"))
    
    @property
    def story_arc(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("story_arc"))
    
    @property
    def cell_reorganization(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cell_reorganization"))
    
    @property
    def missing_elements(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("missing_elements"))
    
    @property
    def recommended_flow(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recommended_flow"))
    
    


class SupplyChainPipelineConfigAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SupplyChainPipelineConfig")
        self._properties: typing.Set[str] = set([  "ontologies",  "data_sources",  "quality_thresholds",  ])
        self._props = SupplyChainPipelineConfigProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SupplyChainPipelineConfigProperties":
        return self._props


class SupplyChainPipelineConfigViewer(SupplyChainPipelineConfigAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SupplyChainPipelineConfigProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def ontologies(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("ontologies"))
    
    @property
    def data_sources(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_sources"))
    
    @property
    def quality_thresholds(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("quality_thresholds"))
    
    


class TargetParsingResultAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TargetParsingResult")
        self._properties: typing.Set[str] = set([  "key_themes",  "quantitative_targets",  "timeframes",  "stakeholders",  "success_indicators",  "suggested_category",  "suggested_priority",  "complexity_score",  "required_data_types",  "suggested_metrics",  "potential_data_sources",  "confidence",  ])
        self._props = TargetParsingResultProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TargetParsingResultProperties":
        return self._props


class TargetParsingResultViewer(TargetParsingResultAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class TargetParsingResultProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def key_themes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("key_themes"))
    
    @property
    def quantitative_targets(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("quantitative_targets"))
    
    @property
    def timeframes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timeframes"))
    
    @property
    def stakeholders(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("stakeholders"))
    
    @property
    def success_indicators(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success_indicators"))
    
    @property
    def suggested_category(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("suggested_category"))
    
    @property
    def suggested_priority(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("suggested_priority"))
    
    @property
    def complexity_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("complexity_score"))
    
    @property
    def required_data_types(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("required_data_types"))
    
    @property
    def suggested_metrics(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("suggested_metrics"))
    
    @property
    def potential_data_sources(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("potential_data_sources"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    


class TradingPipelineConfigAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TradingPipelineConfig")
        self._properties: typing.Set[str] = set([  "ontologies",  "data_sources",  "quality_thresholds",  ])
        self._props = TradingPipelineConfigProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TradingPipelineConfigProperties":
        return self._props


class TradingPipelineConfigViewer(TradingPipelineConfigAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class TradingPipelineConfigProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def ontologies(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("ontologies"))
    
    @property
    def data_sources(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_sources"))
    
    @property
    def quality_thresholds(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("quality_thresholds"))
    
    


class TransformationStrategyAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TransformationStrategy")
        self._properties: typing.Set[str] = set([  "source_schema",  "target_schema",  "transformation_rules",  "validation_logic",  "performance_optimizations",  "error_handling",  ])
        self._props = TransformationStrategyProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TransformationStrategyProperties":
        return self._props


class TransformationStrategyViewer(TransformationStrategyAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class TransformationStrategyProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def source_schema(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source_schema"))
    
    @property
    def target_schema(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("target_schema"))
    
    @property
    def transformation_rules(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transformation_rules"))
    
    @property
    def validation_logic(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("validation_logic"))
    
    @property
    def performance_optimizations(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("performance_optimizations"))
    
    @property
    def error_handling(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error_handling"))
    
    


class VesselSpecificationsAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VesselSpecifications")
        self._properties: typing.Set[str] = set([  "vessel_id",  "vessel_type",  "length",  "width",  "draft",  "cargo_capacity",  "current_load",  "fuel_consumption",  ])
        self._props = VesselSpecificationsProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VesselSpecificationsProperties":
        return self._props


class VesselSpecificationsViewer(VesselSpecificationsAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VesselSpecificationsProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def vessel_id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("vessel_id"))
    
    @property
    def vessel_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("vessel_type"))
    
    @property
    def length(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("length"))
    
    @property
    def width(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("width"))
    
    @property
    def draft(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("draft"))
    
    @property
    def cargo_capacity(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cargo_capacity"))
    
    @property
    def current_load(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("current_load"))
    
    @property
    def fuel_consumption(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("fuel_consumption"))
    
    


class WaterwayConditionsAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("WaterwayConditions")
        self._properties: typing.Set[str] = set([  "water_level",  "flow_rate",  "navigation_status",  "ice_conditions",  "weather_impact",  "lock_delays",  "depth_restrictions",  ])
        self._props = WaterwayConditionsProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "WaterwayConditionsProperties":
        return self._props


class WaterwayConditionsViewer(WaterwayConditionsAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class WaterwayConditionsProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def water_level(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("water_level"))
    
    @property
    def flow_rate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("flow_rate"))
    
    @property
    def navigation_status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("navigation_status"))
    
    @property
    def ice_conditions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("ice_conditions"))
    
    @property
    def weather_impact(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("weather_impact"))
    
    @property
    def lock_delays(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lock_delays"))
    
    @property
    def depth_restrictions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("depth_restrictions"))
    
    


class WorkflowPrepopulationAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("WorkflowPrepopulation")
        self._properties: typing.Set[str] = set([  "operations_data",  "governance_data",  "review_data",  ])
        self._props = WorkflowPrepopulationProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "WorkflowPrepopulationProperties":
        return self._props


class WorkflowPrepopulationViewer(WorkflowPrepopulationAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class WorkflowPrepopulationProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def operations_data(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("operations_data"))
    
    @property
    def governance_data(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("governance_data"))
    
    @property
    def review_data(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("review_data"))
    
    


class ZeroStartDiscoveryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ZeroStartDiscovery")
        self._properties: typing.Set[str] = set([  "business_domain",  "use_case_description",  "required_data_types",  "geographic_scope",  "time_period_requirements",  "max_sources_to_find",  "preferred_source_types",  "exclude_paid_sources",  "require_api_access",  "search_strategy",  "include_academic_sources",  "include_government_sources",  "include_commercial_sources",  ])
        self._props = ZeroStartDiscoveryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ZeroStartDiscoveryProperties":
        return self._props


class ZeroStartDiscoveryViewer(ZeroStartDiscoveryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ZeroStartDiscoveryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def business_domain(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("business_domain"))
    
    @property
    def use_case_description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("use_case_description"))
    
    @property
    def required_data_types(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("required_data_types"))
    
    @property
    def geographic_scope(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("geographic_scope"))
    
    @property
    def time_period_requirements(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("time_period_requirements"))
    
    @property
    def max_sources_to_find(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("max_sources_to_find"))
    
    @property
    def preferred_source_types(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("preferred_source_types"))
    
    @property
    def exclude_paid_sources(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("exclude_paid_sources"))
    
    @property
    def require_api_access(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("require_api_access"))
    
    @property
    def search_strategy(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("search_strategy"))
    
    @property
    def include_academic_sources(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("include_academic_sources"))
    
    @property
    def include_government_sources(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("include_government_sources"))
    
    @property
    def include_commercial_sources(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("include_commercial_sources"))
    
    

