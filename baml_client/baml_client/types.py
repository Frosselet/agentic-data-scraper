# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
import typing_extensions
from enum import Enum


from pydantic import BaseModel, ConfigDict


import baml_py

CheckT = typing_extensions.TypeVar('CheckT')
CheckName = typing_extensions.TypeVar('CheckName', bound=str)

class Check(BaseModel):
    name: str
    expression: str
    status: str
class Checked(BaseModel, typing.Generic[CheckT, CheckName]):
    value: CheckT
    checks: typing.Dict[CheckName, Check]

def get_checks(checks: typing.Dict[CheckName, Check]) -> typing.List[Check]:
    return list(checks.values())

def all_succeeded(checks: typing.Dict[CheckName, Check]) -> bool:
    return all(check.status == "succeeded" for check in get_checks(checks))
# #########################################################################
# Generated enums (8)
# #########################################################################

class DataSourceType(str, Enum):
    API = "API"
    DATABASE = "DATABASE"
    FILE_SYSTEM = "FILE_SYSTEM"
    WEB_SCRAPING = "WEB_SCRAPING"
    STREAM = "STREAM"
    CLOUD_STORAGE = "CLOUD_STORAGE"

class DiscoveryPath(str, Enum):
    KNOWN_SOURCE = "KNOWN_SOURCE"
    ZERO_START = "ZERO_START"

class NavigationPriority(str, Enum):
    COST_OPTIMIZATION = "COST_OPTIMIZATION"
    TIME_CRITICAL = "TIME_CRITICAL"
    RISK_MITIGATION = "RISK_MITIGATION"
    FUEL_EFFICIENCY = "FUEL_EFFICIENCY"
    RELIABILITY = "RELIABILITY"

class RiskLevel(str, Enum):
    LOW = "LOW"
    MODERATE = "MODERATE"
    HIGH = "HIGH"
    CRITICAL = "CRITICAL"

class TargetCategory(str, Enum):
    REVENUE = "REVENUE"
    MARKET_EXPANSION = "MARKET_EXPANSION"
    OPERATIONAL_EFFICIENCY = "OPERATIONAL_EFFICIENCY"
    CUSTOMER_EXPERIENCE = "CUSTOMER_EXPERIENCE"
    INNOVATION = "INNOVATION"
    COMPLIANCE = "COMPLIANCE"
    RISK_MANAGEMENT = "RISK_MANAGEMENT"
    COST_REDUCTION = "COST_REDUCTION"
    DIGITAL_TRANSFORMATION = "DIGITAL_TRANSFORMATION"
    SUSTAINABILITY = "SUSTAINABILITY"
    TALENT_DEVELOPMENT = "TALENT_DEVELOPMENT"
    STRATEGIC_PARTNERSHIP = "STRATEGIC_PARTNERSHIP"

class TargetPriority(str, Enum):
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"

class TransportMode(str, Enum):
    RIVER = "RIVER"
    RAIL = "RAIL"
    TRUCK = "TRUCK"
    MULTIMODAL = "MULTIMODAL"

class UpdateFrequency(str, Enum):
    REAL_TIME = "REAL_TIME"
    HOURLY = "HOURLY"
    DAILY = "DAILY"
    WEEKLY = "WEEKLY"
    MONTHLY = "MONTHLY"
    QUARTERLY = "QUARTERLY"
    YEARLY = "YEARLY"
    STATIC = "STATIC"

# #########################################################################
# Generated classes (40)
# #########################################################################

class AgriculturePipelineConfig(BaseModel):
    ontologies: typing.List[str]
    data_sources: typing.List[str]
    quality_thresholds: typing.Dict[str, float]

class AlignmentScore(BaseModel):
    overall_score: float
    confidence: float
    strategic_fit: float
    impact_potential: float
    timeline_feasibility: float
    resource_efficiency: float
    risk_assessment: float
    dependency_analysis: float
    reasoning: str
    key_factors: typing.List[str]
    risk_factors: typing.List[str]
    recommendations: typing.List[str]

class BusinessContext(BaseModel):
    question: str
    success_criteria: str
    timeline: str
    budget: str
    risk_tolerance: str
    persona_id: str
    interaction_level: str

class CellMove(BaseModel):
    current_position: int
    suggested_position: int
    reason: str
    cell_type: str
    content_summary: str

class CongestionAlert(BaseModel):
    location: str
    river_mile: float
    severity: RiskLevel
    estimated_delay_hours: float
    affected_vessels: int
    alternative_routes: typing.List[str]
    cost_impact_percent: float

class DataBusinessCanvas(BaseModel):
    value_propositions: typing.List[str]
    key_activities: typing.List[str]
    key_resources: typing.List[str]
    key_partnerships: typing.List[str]
    customer_segments: typing.List[str]
    customer_relationships: typing.List[str]
    channels: typing.List[str]
    cost_structure: typing.List[str]
    revenue_streams: typing.List[str]
    data_assets: typing.List[str]
    intelligence_capabilities: typing.List[str]
    competitive_advantages: typing.List[str]
    business_domain: str
    use_case_description: str
    timeline: str
    budget: str

class DataContract(BaseModel):
    source_requirements: typing.List[str]
    validation_rules: typing.List[str]
    transformation_specs: typing.List[str]
    quality_thresholds: typing.Dict[str, float]
    security_requirements: typing.List[str]
    compliance_rules: typing.List[str]

class DataSource(BaseModel):
    type: str
    url: typing.Optional[str] = None
    authentication_type: typing.Optional[str] = None
    access_patterns: typing.List[str]
    rate_limits: typing.Optional[int] = None
    documentation_url: typing.Optional[str] = None

class DataSourceMetadata(BaseModel):
    name: str
    url: str
    description: str
    source_type: DataSourceType
    access_method: str
    authentication_required: bool
    authentication_method: typing.Optional[str] = None
    rate_limits: typing.Optional[typing.Dict[str, str]] = None
    data_formats: typing.List[str]
    schema_available: bool
    schema_url: typing.Optional[str] = None
    sample_data_url: typing.Optional[str] = None
    data_volume_estimate: typing.Optional[str] = None
    update_frequency: typing.Optional[UpdateFrequency] = None
    historical_data_available: bool
    historical_range: typing.Optional[str] = None
    data_quality_score: typing.Optional[float] = None
    completeness_estimate: typing.Optional[float] = None
    accuracy_indicators: typing.List[str]
    known_data_issues: typing.List[str]
    license_type: typing.Optional[str] = None
    terms_of_use_url: typing.Optional[str] = None
    privacy_considerations: typing.List[str]
    compliance_standards: typing.List[str]
    relevance_score: float
    business_domains: typing.List[str]
    use_cases: typing.List[str]
    discovery_method: str
    confidence_score: float

class DataSourceRecommendation(BaseModel):
    name: str
    type: str
    description: str
    feasibility_score: float
    cost_estimate: str
    implementation_effort: str
    platform_compatibility: float
    data_quality_expected: float
    access_requirements: typing.List[str]
    sample_data_url: typing.Optional[str] = None
    documentation_url: typing.Optional[str] = None
    pros: typing.List[str]
    cons: typing.List[str]
    semantic_vocabularies: typing.List[str]

class DiscoveryResult(BaseModel):
    discovery_path: DiscoveryPath
    discovered_sources: typing.List["DataSourceMetadata"]
    total_sources_found: int
    search_queries_used: typing.List[str]
    discovery_duration_seconds: float
    recommended_next_steps: typing.List[str]
    prefilled_operations_data: typing.Dict[str, str]
    prefilled_governance_data: typing.Dict[str, str]

class ETKLCoordinationPlan(BaseModel):
    coordination_strategy: str
    work_stream_priorities: typing.List[str]
    critical_dependencies: typing.List[str]
    synchronization_points: typing.List[str]
    quality_gates: typing.List[str]
    escalation_triggers: typing.List[str]
    success_metrics: typing.List[str]

class ETKLManifestoCompliance(BaseModel):
    manifesto_section: str
    compliance_level: str
    evidence: typing.List[str]
    gaps: typing.List[str]
    recommendations: typing.List[str]

class ETKLPrincipleViolation(BaseModel):
    principle_violated: str
    severity: str
    location: str
    description: str
    business_impact: str
    corrective_action: str
    priority: int

class ETKLVisionAssessment(BaseModel):
    overall_alignment_score: float
    theoretical_consistency: float
    technical_implementation: float
    narrative_coherence: float
    governance_compliance: float
    critical_gaps: typing.List[str]
    misalignment_risks: typing.List[str]
    recommended_actions: typing.List[str]

class ETKLWorkStreamAnalysis(BaseModel):
    work_stream: str
    current_state: str
    target_state: str
    alignment_score: float
    key_deliverables: typing.List[str]
    dependencies: typing.List[str]
    risks: typing.List[str]
    next_actions: typing.List[str]

class ExecutiveTarget(BaseModel):
    id: str
    title: str
    description: str
    category: TargetCategory
    priority: TargetPriority
    owner: str
    owner_role: str
    deadline: typing.Optional[str] = None
    success_metrics: typing.List[str]
    target_value: typing.Optional[str] = None
    baseline_value: typing.Optional[str] = None
    business_domain: str
    stakeholders: typing.List[str]
    dependencies: typing.List[str]
    constraints: typing.List[str]
    status: str

class FeasibilityAnalysis(BaseModel):
    overall_feasibility: str
    technical_risks: typing.List[str]
    business_risks: typing.List[str]
    mitigation_strategies: typing.List[str]
    platform_gaps: typing.List[str]
    recommended_alternatives: typing.List[str]
    estimated_timeline_weeks: int
    confidence_level: float

class GeneratedPipeline(BaseModel):
    lambda_code: str
    deployment_config: str
    monitoring_code: str
    validation_code: str
    documentation: str
    test_cases: typing.List[str]

class KnownSourceRequest(BaseModel):
    source_urls: typing.List[str]
    expected_source_type: typing.Optional[DataSourceType] = None
    specific_datasets: typing.Optional[typing.List[str]] = None
    collection_depth: str

class MarketOpportunity(BaseModel):
    commodity: str
    origin_price: float
    destination_price: float
    arbitrage_potential: float
    transport_cost: float
    net_profit_per_ton: float
    market_window_days: int
    confidence_level: float

class NavigationRecommendation(BaseModel):
    recommended_route: "RouteOption"
    alternative_routes: typing.List["RouteOption"]
    risk_factors: typing.List[str]
    cost_analysis: typing.Dict[str, float]
    timing_considerations: typing.List[str]
    weather_alerts: typing.List[str]
    market_insights: typing.List[str]
    action_items: typing.List[str]
    decision_rationale: str

class NotebookSection(BaseModel):
    section_name: str
    cell_range: str
    cell_types: typing.List[str]
    purpose: str
    story_function: str
    narrative_quality: float
    issues: typing.List[str]
    suggestions: typing.List[str]

class NotebookStructure(BaseModel):
    title: str
    sections: typing.List["NotebookSection"]
    total_cells: int
    story_flow_score: float
    narrative_issues: typing.List[str]
    improvement_suggestions: typing.List[str]

class ParsedData(BaseModel):
    format: str
    schema: typing.Dict[str, str]
    quality_score: float
    anomalies: typing.List[str]
    encoding: typing.Optional[str] = None
    size_mb: float

class RouteOption(BaseModel):
    route_id: str
    transport_mode: TransportMode
    total_distance_miles: float
    estimated_travel_time_hours: float
    total_cost_usd: float
    risk_assessment: RiskLevel
    fuel_cost: float
    lock_fees: typing.List[float]
    delay_probability: float
    confidence_score: float
    route_segments: typing.List[str]
    alternative_modes: typing.List[str]
    cost_breakdown: typing.Dict[str, float]

class RoutingRequest(BaseModel):
    origin_port: str
    destination_port: str
    commodity: str
    quantity_tons: float
    departure_time: str
    priority: NavigationPriority
    max_delay_hours: typing.Optional[int] = None
    budget_constraint: typing.Optional[float] = None
    vessel_specs: typing.Optional["VesselSpecifications"] = None

class SOWContract(BaseModel):
    project_title: str
    executive_summary: str
    business_objectives: typing.List[str]
    success_metrics: typing.List[str]
    data_sources: typing.List["DataSourceRecommendation"]
    technical_approach: str
    deliverables: typing.List[str]
    timeline_weeks: int
    cost_estimate: str
    risk_assessment: str
    acceptance_criteria: typing.List[str]
    semantic_framework: str

class SecurityDecision(BaseModel):
    risk_level: str
    decision_required: str
    context: str
    recommended_action: str
    human_approval_needed: bool

class SemanticAnnotation(BaseModel):
    ontology_mappings: typing.Dict[str, str]
    skos_concepts: typing.List[str]
    owl_alignments: typing.List[str]
    semantic_quality_score: float
    domain_coverage: float
    linked_entities: typing.List[str]

class StoryArc(BaseModel):
    phase: str
    description: str
    cells_needed: int
    current_status: str
    improvement_actions: typing.List[str]

class StorytellingPlan(BaseModel):
    narrative_theme: str
    target_audience: str
    learning_objectives: typing.List[str]
    story_arc: typing.List["StoryArc"]
    cell_reorganization: typing.List["CellMove"]
    missing_elements: typing.List[str]
    recommended_flow: typing.List[str]

class SupplyChainPipelineConfig(BaseModel):
    ontologies: typing.List[str]
    data_sources: typing.List[str]
    quality_thresholds: typing.Dict[str, float]

class TargetParsingResult(BaseModel):
    key_themes: typing.List[str]
    quantitative_targets: typing.List[str]
    timeframes: typing.List[str]
    stakeholders: typing.List[str]
    success_indicators: typing.List[str]
    suggested_category: typing.Optional[TargetCategory] = None
    suggested_priority: typing.Optional[TargetPriority] = None
    complexity_score: float
    required_data_types: typing.List[str]
    suggested_metrics: typing.List[str]
    potential_data_sources: typing.List[str]
    confidence: float

class TradingPipelineConfig(BaseModel):
    ontologies: typing.List[str]
    data_sources: typing.List[str]
    quality_thresholds: typing.Dict[str, float]

class TransformationStrategy(BaseModel):
    source_schema: typing.Dict[str, str]
    target_schema: typing.Dict[str, str]
    transformation_rules: typing.List[str]
    validation_logic: typing.List[str]
    performance_optimizations: typing.List[str]
    error_handling: typing.List[str]

class VesselSpecifications(BaseModel):
    vessel_id: str
    vessel_type: str
    length: float
    width: float
    draft: float
    cargo_capacity: float
    current_load: float
    fuel_consumption: float

class WaterwayConditions(BaseModel):
    water_level: float
    flow_rate: float
    navigation_status: str
    ice_conditions: typing.Optional[str] = None
    weather_impact: typing.Optional[str] = None
    lock_delays: typing.List[int]
    depth_restrictions: typing.List[float]

class WorkflowPrepopulation(BaseModel):
    operations_data: typing.Dict[str, str]
    governance_data: typing.Dict[str, str]
    review_data: typing.Dict[str, str]

class ZeroStartDiscovery(BaseModel):
    business_domain: str
    use_case_description: str
    required_data_types: typing.List[str]
    geographic_scope: typing.Optional[str] = None
    time_period_requirements: typing.Optional[str] = None
    max_sources_to_find: int
    preferred_source_types: typing.Optional[typing.List[DataSourceType]] = None
    exclude_paid_sources: bool
    require_api_access: bool
    search_strategy: str
    include_academic_sources: bool
    include_government_sources: bool
    include_commercial_sources: bool

# #########################################################################
# Generated type aliases (0)
# #########################################################################
