# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
import typing_extensions
import baml_py

from . import stream_types, types, type_builder
from .parser import LlmResponseParser, LlmStreamParser
from .runtime import DoNotUseDirectlyCallManager, BamlCallOptions
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME as __runtime__

class BamlSyncClient:
    __options: DoNotUseDirectlyCallManager
    __stream_client: "BamlStreamClient"
    __http_request: "BamlHttpRequestClient"
    __http_stream_request: "BamlHttpStreamRequestClient"
    __llm_response_parser: LlmResponseParser
    __llm_stream_parser: LlmStreamParser

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options
        self.__stream_client = BamlStreamClient(options)
        self.__http_request = BamlHttpRequestClient(options)
        self.__http_stream_request = BamlHttpStreamRequestClient(options)
        self.__llm_response_parser = LlmResponseParser(options)
        self.__llm_stream_parser = LlmStreamParser(options)

    def __getstate__(self):
        # Return state needed for pickling
        return {"options": self.__options}

    def __setstate__(self, state):
        # Restore state from pickling
        self.__options = state["options"]
        self.__stream_client = BamlStreamClient(self.__options)
        self.__http_request = BamlHttpRequestClient(self.__options)
        self.__http_stream_request = BamlHttpStreamRequestClient(self.__options)
        self.__llm_response_parser = LlmResponseParser(self.__options)
        self.__llm_stream_parser = LlmStreamParser(self.__options)

    def with_options(self,
        tb: typing.Optional[type_builder.TypeBuilder] = None,
        client_registry: typing.Optional[baml_py.baml_py.ClientRegistry] = None,
        collector: typing.Optional[typing.Union[baml_py.baml_py.Collector, typing.List[baml_py.baml_py.Collector]]] = None,
        env: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        on_tick: typing.Optional[typing.Callable[[str, baml_py.baml_py.FunctionLog], None]] = None,
    ) -> "BamlSyncClient":
        options: BamlCallOptions = {}
        if tb is not None:
            options["tb"] = tb
        if client_registry is not None:
            options["client_registry"] = client_registry
        if collector is not None:
            options["collector"] = collector
        if env is not None:
            options["env"] = env
        if on_tick is not None:
            options["on_tick"] = on_tick
        return BamlSyncClient(self.__options.merge_options(options))

    @property
    def stream(self):
      return self.__stream_client

    @property
    def request(self):
      return self.__http_request

    @property
    def stream_request(self):
      return self.__http_stream_request

    @property
    def parse(self):
      return self.__llm_response_parser

    @property
    def parse_stream(self):
      return self.__llm_stream_parser
    
    def BusinessContextAgent(self, business_question: str,success_criteria: str,timeline: str,budget: str,risk_tolerance: str,persona_id: str,
        baml_options: BamlCallOptions = {},
    ) -> types.BusinessContext:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.BusinessContextAgent(business_question=business_question,success_criteria=success_criteria,timeline=timeline,budget=budget,risk_tolerance=risk_tolerance,persona_id=persona_id,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="BusinessContextAgent", args={
                "business_question": business_question,"success_criteria": success_criteria,"timeline": timeline,"budget": budget,"risk_tolerance": risk_tolerance,"persona_id": persona_id,
            })
            return typing.cast(types.BusinessContext, result.cast_to(types, types, stream_types, False, __runtime__))
    def CongestionManagementAgent(self, current_traffic: typing.Dict[str, int],lock_queues: typing.Dict[str, int],
        baml_options: BamlCallOptions = {},
    ) -> typing.List["types.CongestionAlert"]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.CongestionManagementAgent(current_traffic=current_traffic,lock_queues=lock_queues,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="CongestionManagementAgent", args={
                "current_traffic": current_traffic,"lock_queues": lock_queues,
            })
            return typing.cast(typing.List["types.CongestionAlert"], result.cast_to(types, types, stream_types, False, __runtime__))
    def DataFetcherAgent(self, data_sources: typing.List["types.DataSource"],security_requirements: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> str:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.DataFetcherAgent(data_sources=data_sources,security_requirements=security_requirements,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="DataFetcherAgent", args={
                "data_sources": data_sources,"security_requirements": security_requirements,
            })
            return typing.cast(str, result.cast_to(types, types, stream_types, False, __runtime__))
    def DataParserAgent(self, raw_data: str,data_format: str,schema_hints: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> types.ParsedData:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.DataParserAgent(raw_data=raw_data,data_format=data_format,schema_hints=schema_hints,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="DataParserAgent", args={
                "raw_data": raw_data,"data_format": data_format,"schema_hints": schema_hints,
            })
            return typing.cast(types.ParsedData, result.cast_to(types, types, stream_types, False, __runtime__))
    def DataTransformerAgent(self, source_data: types.ParsedData,target_schema: typing.Dict[str, str],business_rules: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> types.TransformationStrategy:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.DataTransformerAgent(source_data=source_data,target_schema=target_schema,business_rules=business_rules,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="DataTransformerAgent", args={
                "source_data": source_data,"target_schema": target_schema,"business_rules": business_rules,
            })
            return typing.cast(types.TransformationStrategy, result.cast_to(types, types, stream_types, False, __runtime__))
    def DecisionSupportAgent(self, current_situation: str,available_options: typing.List["types.RouteOption"],constraints: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> str:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.DecisionSupportAgent(current_situation=current_situation,available_options=available_options,constraints=constraints,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="DecisionSupportAgent", args={
                "current_situation": current_situation,"available_options": available_options,"constraints": constraints,
            })
            return typing.cast(str, result.cast_to(types, types, stream_types, False, __runtime__))
    def EconomicOptimizationAgent(self, market_data: typing.Dict[str, float],transport_rates: typing.Dict[str, float],routing_options: typing.List["types.RouteOption"],
        baml_options: BamlCallOptions = {},
    ) -> typing.List["types.MarketOpportunity"]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.EconomicOptimizationAgent(market_data=market_data,transport_rates=transport_rates,routing_options=routing_options,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="EconomicOptimizationAgent", args={
                "market_data": market_data,"transport_rates": transport_rates,"routing_options": routing_options,
            })
            return typing.cast(typing.List["types.MarketOpportunity"], result.cast_to(types, types, stream_types, False, __runtime__))
    def FeasibilityAnalyzerAgent(self, business_context: types.BusinessContext,recommended_sources: typing.List["types.DataSourceRecommendation"],
        baml_options: BamlCallOptions = {},
    ) -> types.FeasibilityAnalysis:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.FeasibilityAnalyzerAgent(business_context=business_context,recommended_sources=recommended_sources,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="FeasibilityAnalyzerAgent", args={
                "business_context": business_context,"recommended_sources": recommended_sources,
            })
            return typing.cast(types.FeasibilityAnalysis, result.cast_to(types, types, stream_types, False, __runtime__))
    def HydrologicalRiskAgent(self, waterway_segments: typing.List[str],forecast_period_days: int,
        baml_options: BamlCallOptions = {},
    ) -> typing.Dict[str, types.RiskLevel]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.HydrologicalRiskAgent(waterway_segments=waterway_segments,forecast_period_days=forecast_period_days,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="HydrologicalRiskAgent", args={
                "waterway_segments": waterway_segments,"forecast_period_days": forecast_period_days,
            })
            return typing.cast(typing.Dict[str, types.RiskLevel], result.cast_to(types, types, stream_types, False, __runtime__))
    def MultiModalOptimizationAgent(self, origin: str,destination: str,commodity: str,quantity_tons: float,service_requirements: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> typing.List["types.RouteOption"]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.MultiModalOptimizationAgent(origin=origin,destination=destination,commodity=commodity,quantity_tons=quantity_tons,service_requirements=service_requirements,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="MultiModalOptimizationAgent", args={
                "origin": origin,"destination": destination,"commodity": commodity,"quantity_tons": quantity_tons,"service_requirements": service_requirements,
            })
            return typing.cast(typing.List["types.RouteOption"], result.cast_to(types, types, stream_types, False, __runtime__))
    def NavigationIntelligenceAgent(self, routing_request: types.RoutingRequest,current_conditions: types.WaterwayConditions,
        baml_options: BamlCallOptions = {},
    ) -> types.NavigationRecommendation:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.NavigationIntelligenceAgent(routing_request=routing_request,current_conditions=current_conditions,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="NavigationIntelligenceAgent", args={
                "routing_request": routing_request,"current_conditions": current_conditions,
            })
            return typing.cast(types.NavigationRecommendation, result.cast_to(types, types, stream_types, False, __runtime__))
    def PersonaResponseAgent(self, base_response: str,persona_id: str,interaction_level: str,technical_depth: str,
        baml_options: BamlCallOptions = {},
    ) -> str:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.PersonaResponseAgent(base_response=base_response,persona_id=persona_id,interaction_level=interaction_level,technical_depth=technical_depth,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="PersonaResponseAgent", args={
                "base_response": base_response,"persona_id": persona_id,"interaction_level": interaction_level,"technical_depth": technical_depth,
            })
            return typing.cast(str, result.cast_to(types, types, stream_types, False, __runtime__))
    def PlatformCapabilityAgent(self, data_sources: typing.List[str],requirements: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> typing.Dict[str, float]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.PlatformCapabilityAgent(data_sources=data_sources,requirements=requirements,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="PlatformCapabilityAgent", args={
                "data_sources": data_sources,"requirements": requirements,
            })
            return typing.cast(typing.Dict[str, float], result.cast_to(types, types, stream_types, False, __runtime__))
    def SOWGeneratorAgent(self, business_context: types.BusinessContext,selected_sources: typing.List["types.DataSourceRecommendation"],feasibility_analysis: types.FeasibilityAnalysis,
        baml_options: BamlCallOptions = {},
    ) -> types.SOWContract:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.SOWGeneratorAgent(business_context=business_context,selected_sources=selected_sources,feasibility_analysis=feasibility_analysis,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="SOWGeneratorAgent", args={
                "business_context": business_context,"selected_sources": selected_sources,"feasibility_analysis": feasibility_analysis,
            })
            return typing.cast(types.SOWContract, result.cast_to(types, types, stream_types, False, __runtime__))
    def SOWInterpreterAgent(self, sow_document: str,document_format: str,
        baml_options: BamlCallOptions = {},
    ) -> types.DataContract:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.SOWInterpreterAgent(sow_document=sow_document,document_format=document_format,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="SOWInterpreterAgent", args={
                "sow_document": sow_document,"document_format": document_format,
            })
            return typing.cast(types.DataContract, result.cast_to(types, types, stream_types, False, __runtime__))
    def SecurityDecisionAgent(self, operation_context: str,risk_assessment: str,data_sensitivity: str,
        baml_options: BamlCallOptions = {},
    ) -> types.SecurityDecision:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.SecurityDecisionAgent(operation_context=operation_context,risk_assessment=risk_assessment,data_sensitivity=data_sensitivity,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="SecurityDecisionAgent", args={
                "operation_context": operation_context,"risk_assessment": risk_assessment,"data_sensitivity": data_sensitivity,
            })
            return typing.cast(types.SecurityDecision, result.cast_to(types, types, stream_types, False, __runtime__))
    def SemanticIntegratorAgent(self, transformed_data: types.ParsedData,business_domain: str,existing_ontologies: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> types.SemanticAnnotation:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.SemanticIntegratorAgent(transformed_data=transformed_data,business_domain=business_domain,existing_ontologies=existing_ontologies,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="SemanticIntegratorAgent", args={
                "transformed_data": transformed_data,"business_domain": business_domain,"existing_ontologies": existing_ontologies,
            })
            return typing.cast(types.SemanticAnnotation, result.cast_to(types, types, stream_types, False, __runtime__))
    def SourceDiscoveryAgent(self, business_context: types.BusinessContext,platform_capabilities: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> typing.List["types.DataSourceRecommendation"]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.SourceDiscoveryAgent(business_context=business_context,platform_capabilities=platform_capabilities,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="SourceDiscoveryAgent", args={
                "business_context": business_context,"platform_capabilities": platform_capabilities,
            })
            return typing.cast(typing.List["types.DataSourceRecommendation"], result.cast_to(types, types, stream_types, False, __runtime__))
    def SupervisorAgent(self, sow_document: str,document_format: str,human_feedback: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> types.GeneratedPipeline:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.SupervisorAgent(sow_document=sow_document,document_format=document_format,human_feedback=human_feedback,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="SupervisorAgent", args={
                "sow_document": sow_document,"document_format": document_format,"human_feedback": human_feedback,
            })
            return typing.cast(types.GeneratedPipeline, result.cast_to(types, types, stream_types, False, __runtime__))
    


class BamlStreamClient:
    __options: DoNotUseDirectlyCallManager

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options

    def BusinessContextAgent(self, business_question: str,success_criteria: str,timeline: str,budget: str,risk_tolerance: str,persona_id: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.BusinessContext, types.BusinessContext]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="BusinessContextAgent", args={
            "business_question": business_question,"success_criteria": success_criteria,"timeline": timeline,"budget": budget,"risk_tolerance": risk_tolerance,"persona_id": persona_id,
        })
        return baml_py.BamlSyncStream[stream_types.BusinessContext, types.BusinessContext](
          result,
          lambda x: typing.cast(stream_types.BusinessContext, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.BusinessContext, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def CongestionManagementAgent(self, current_traffic: typing.Dict[str, int],lock_queues: typing.Dict[str, int],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.List["stream_types.CongestionAlert"], typing.List["types.CongestionAlert"]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="CongestionManagementAgent", args={
            "current_traffic": current_traffic,"lock_queues": lock_queues,
        })
        return baml_py.BamlSyncStream[typing.List["stream_types.CongestionAlert"], typing.List["types.CongestionAlert"]](
          result,
          lambda x: typing.cast(typing.List["stream_types.CongestionAlert"], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.List["types.CongestionAlert"], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def DataFetcherAgent(self, data_sources: typing.List["types.DataSource"],security_requirements: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[str, str]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="DataFetcherAgent", args={
            "data_sources": data_sources,"security_requirements": security_requirements,
        })
        return baml_py.BamlSyncStream[str, str](
          result,
          lambda x: typing.cast(str, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(str, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def DataParserAgent(self, raw_data: str,data_format: str,schema_hints: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.ParsedData, types.ParsedData]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="DataParserAgent", args={
            "raw_data": raw_data,"data_format": data_format,"schema_hints": schema_hints,
        })
        return baml_py.BamlSyncStream[stream_types.ParsedData, types.ParsedData](
          result,
          lambda x: typing.cast(stream_types.ParsedData, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.ParsedData, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def DataTransformerAgent(self, source_data: types.ParsedData,target_schema: typing.Dict[str, str],business_rules: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.TransformationStrategy, types.TransformationStrategy]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="DataTransformerAgent", args={
            "source_data": source_data,"target_schema": target_schema,"business_rules": business_rules,
        })
        return baml_py.BamlSyncStream[stream_types.TransformationStrategy, types.TransformationStrategy](
          result,
          lambda x: typing.cast(stream_types.TransformationStrategy, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.TransformationStrategy, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def DecisionSupportAgent(self, current_situation: str,available_options: typing.List["types.RouteOption"],constraints: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[str, str]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="DecisionSupportAgent", args={
            "current_situation": current_situation,"available_options": available_options,"constraints": constraints,
        })
        return baml_py.BamlSyncStream[str, str](
          result,
          lambda x: typing.cast(str, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(str, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def EconomicOptimizationAgent(self, market_data: typing.Dict[str, float],transport_rates: typing.Dict[str, float],routing_options: typing.List["types.RouteOption"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.List["stream_types.MarketOpportunity"], typing.List["types.MarketOpportunity"]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="EconomicOptimizationAgent", args={
            "market_data": market_data,"transport_rates": transport_rates,"routing_options": routing_options,
        })
        return baml_py.BamlSyncStream[typing.List["stream_types.MarketOpportunity"], typing.List["types.MarketOpportunity"]](
          result,
          lambda x: typing.cast(typing.List["stream_types.MarketOpportunity"], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.List["types.MarketOpportunity"], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def FeasibilityAnalyzerAgent(self, business_context: types.BusinessContext,recommended_sources: typing.List["types.DataSourceRecommendation"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.FeasibilityAnalysis, types.FeasibilityAnalysis]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="FeasibilityAnalyzerAgent", args={
            "business_context": business_context,"recommended_sources": recommended_sources,
        })
        return baml_py.BamlSyncStream[stream_types.FeasibilityAnalysis, types.FeasibilityAnalysis](
          result,
          lambda x: typing.cast(stream_types.FeasibilityAnalysis, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.FeasibilityAnalysis, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def HydrologicalRiskAgent(self, waterway_segments: typing.List[str],forecast_period_days: int,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.Dict[str, types.RiskLevel], typing.Dict[str, types.RiskLevel]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="HydrologicalRiskAgent", args={
            "waterway_segments": waterway_segments,"forecast_period_days": forecast_period_days,
        })
        return baml_py.BamlSyncStream[typing.Dict[str, types.RiskLevel], typing.Dict[str, types.RiskLevel]](
          result,
          lambda x: typing.cast(typing.Dict[str, types.RiskLevel], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.Dict[str, types.RiskLevel], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def MultiModalOptimizationAgent(self, origin: str,destination: str,commodity: str,quantity_tons: float,service_requirements: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.List["stream_types.RouteOption"], typing.List["types.RouteOption"]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="MultiModalOptimizationAgent", args={
            "origin": origin,"destination": destination,"commodity": commodity,"quantity_tons": quantity_tons,"service_requirements": service_requirements,
        })
        return baml_py.BamlSyncStream[typing.List["stream_types.RouteOption"], typing.List["types.RouteOption"]](
          result,
          lambda x: typing.cast(typing.List["stream_types.RouteOption"], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.List["types.RouteOption"], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def NavigationIntelligenceAgent(self, routing_request: types.RoutingRequest,current_conditions: types.WaterwayConditions,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.NavigationRecommendation, types.NavigationRecommendation]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="NavigationIntelligenceAgent", args={
            "routing_request": routing_request,"current_conditions": current_conditions,
        })
        return baml_py.BamlSyncStream[stream_types.NavigationRecommendation, types.NavigationRecommendation](
          result,
          lambda x: typing.cast(stream_types.NavigationRecommendation, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.NavigationRecommendation, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def PersonaResponseAgent(self, base_response: str,persona_id: str,interaction_level: str,technical_depth: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[str, str]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="PersonaResponseAgent", args={
            "base_response": base_response,"persona_id": persona_id,"interaction_level": interaction_level,"technical_depth": technical_depth,
        })
        return baml_py.BamlSyncStream[str, str](
          result,
          lambda x: typing.cast(str, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(str, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def PlatformCapabilityAgent(self, data_sources: typing.List[str],requirements: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.Dict[str, float], typing.Dict[str, float]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="PlatformCapabilityAgent", args={
            "data_sources": data_sources,"requirements": requirements,
        })
        return baml_py.BamlSyncStream[typing.Dict[str, float], typing.Dict[str, float]](
          result,
          lambda x: typing.cast(typing.Dict[str, float], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.Dict[str, float], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def SOWGeneratorAgent(self, business_context: types.BusinessContext,selected_sources: typing.List["types.DataSourceRecommendation"],feasibility_analysis: types.FeasibilityAnalysis,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.SOWContract, types.SOWContract]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="SOWGeneratorAgent", args={
            "business_context": business_context,"selected_sources": selected_sources,"feasibility_analysis": feasibility_analysis,
        })
        return baml_py.BamlSyncStream[stream_types.SOWContract, types.SOWContract](
          result,
          lambda x: typing.cast(stream_types.SOWContract, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.SOWContract, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def SOWInterpreterAgent(self, sow_document: str,document_format: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.DataContract, types.DataContract]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="SOWInterpreterAgent", args={
            "sow_document": sow_document,"document_format": document_format,
        })
        return baml_py.BamlSyncStream[stream_types.DataContract, types.DataContract](
          result,
          lambda x: typing.cast(stream_types.DataContract, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.DataContract, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def SecurityDecisionAgent(self, operation_context: str,risk_assessment: str,data_sensitivity: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.SecurityDecision, types.SecurityDecision]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="SecurityDecisionAgent", args={
            "operation_context": operation_context,"risk_assessment": risk_assessment,"data_sensitivity": data_sensitivity,
        })
        return baml_py.BamlSyncStream[stream_types.SecurityDecision, types.SecurityDecision](
          result,
          lambda x: typing.cast(stream_types.SecurityDecision, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.SecurityDecision, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def SemanticIntegratorAgent(self, transformed_data: types.ParsedData,business_domain: str,existing_ontologies: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.SemanticAnnotation, types.SemanticAnnotation]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="SemanticIntegratorAgent", args={
            "transformed_data": transformed_data,"business_domain": business_domain,"existing_ontologies": existing_ontologies,
        })
        return baml_py.BamlSyncStream[stream_types.SemanticAnnotation, types.SemanticAnnotation](
          result,
          lambda x: typing.cast(stream_types.SemanticAnnotation, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.SemanticAnnotation, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def SourceDiscoveryAgent(self, business_context: types.BusinessContext,platform_capabilities: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[typing.List["stream_types.DataSourceRecommendation"], typing.List["types.DataSourceRecommendation"]]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="SourceDiscoveryAgent", args={
            "business_context": business_context,"platform_capabilities": platform_capabilities,
        })
        return baml_py.BamlSyncStream[typing.List["stream_types.DataSourceRecommendation"], typing.List["types.DataSourceRecommendation"]](
          result,
          lambda x: typing.cast(typing.List["stream_types.DataSourceRecommendation"], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.List["types.DataSourceRecommendation"], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def SupervisorAgent(self, sow_document: str,document_format: str,human_feedback: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.GeneratedPipeline, types.GeneratedPipeline]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="SupervisorAgent", args={
            "sow_document": sow_document,"document_format": document_format,"human_feedback": human_feedback,
        })
        return baml_py.BamlSyncStream[stream_types.GeneratedPipeline, types.GeneratedPipeline](
          result,
          lambda x: typing.cast(stream_types.GeneratedPipeline, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.GeneratedPipeline, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    

class BamlHttpRequestClient:
    __options: DoNotUseDirectlyCallManager

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options

    def BusinessContextAgent(self, business_question: str,success_criteria: str,timeline: str,budget: str,risk_tolerance: str,persona_id: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="BusinessContextAgent", args={
            "business_question": business_question,"success_criteria": success_criteria,"timeline": timeline,"budget": budget,"risk_tolerance": risk_tolerance,"persona_id": persona_id,
        }, mode="request")
        return result
    def CongestionManagementAgent(self, current_traffic: typing.Dict[str, int],lock_queues: typing.Dict[str, int],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="CongestionManagementAgent", args={
            "current_traffic": current_traffic,"lock_queues": lock_queues,
        }, mode="request")
        return result
    def DataFetcherAgent(self, data_sources: typing.List["types.DataSource"],security_requirements: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DataFetcherAgent", args={
            "data_sources": data_sources,"security_requirements": security_requirements,
        }, mode="request")
        return result
    def DataParserAgent(self, raw_data: str,data_format: str,schema_hints: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DataParserAgent", args={
            "raw_data": raw_data,"data_format": data_format,"schema_hints": schema_hints,
        }, mode="request")
        return result
    def DataTransformerAgent(self, source_data: types.ParsedData,target_schema: typing.Dict[str, str],business_rules: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DataTransformerAgent", args={
            "source_data": source_data,"target_schema": target_schema,"business_rules": business_rules,
        }, mode="request")
        return result
    def DecisionSupportAgent(self, current_situation: str,available_options: typing.List["types.RouteOption"],constraints: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DecisionSupportAgent", args={
            "current_situation": current_situation,"available_options": available_options,"constraints": constraints,
        }, mode="request")
        return result
    def EconomicOptimizationAgent(self, market_data: typing.Dict[str, float],transport_rates: typing.Dict[str, float],routing_options: typing.List["types.RouteOption"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="EconomicOptimizationAgent", args={
            "market_data": market_data,"transport_rates": transport_rates,"routing_options": routing_options,
        }, mode="request")
        return result
    def FeasibilityAnalyzerAgent(self, business_context: types.BusinessContext,recommended_sources: typing.List["types.DataSourceRecommendation"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="FeasibilityAnalyzerAgent", args={
            "business_context": business_context,"recommended_sources": recommended_sources,
        }, mode="request")
        return result
    def HydrologicalRiskAgent(self, waterway_segments: typing.List[str],forecast_period_days: int,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="HydrologicalRiskAgent", args={
            "waterway_segments": waterway_segments,"forecast_period_days": forecast_period_days,
        }, mode="request")
        return result
    def MultiModalOptimizationAgent(self, origin: str,destination: str,commodity: str,quantity_tons: float,service_requirements: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="MultiModalOptimizationAgent", args={
            "origin": origin,"destination": destination,"commodity": commodity,"quantity_tons": quantity_tons,"service_requirements": service_requirements,
        }, mode="request")
        return result
    def NavigationIntelligenceAgent(self, routing_request: types.RoutingRequest,current_conditions: types.WaterwayConditions,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="NavigationIntelligenceAgent", args={
            "routing_request": routing_request,"current_conditions": current_conditions,
        }, mode="request")
        return result
    def PersonaResponseAgent(self, base_response: str,persona_id: str,interaction_level: str,technical_depth: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="PersonaResponseAgent", args={
            "base_response": base_response,"persona_id": persona_id,"interaction_level": interaction_level,"technical_depth": technical_depth,
        }, mode="request")
        return result
    def PlatformCapabilityAgent(self, data_sources: typing.List[str],requirements: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="PlatformCapabilityAgent", args={
            "data_sources": data_sources,"requirements": requirements,
        }, mode="request")
        return result
    def SOWGeneratorAgent(self, business_context: types.BusinessContext,selected_sources: typing.List["types.DataSourceRecommendation"],feasibility_analysis: types.FeasibilityAnalysis,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SOWGeneratorAgent", args={
            "business_context": business_context,"selected_sources": selected_sources,"feasibility_analysis": feasibility_analysis,
        }, mode="request")
        return result
    def SOWInterpreterAgent(self, sow_document: str,document_format: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SOWInterpreterAgent", args={
            "sow_document": sow_document,"document_format": document_format,
        }, mode="request")
        return result
    def SecurityDecisionAgent(self, operation_context: str,risk_assessment: str,data_sensitivity: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SecurityDecisionAgent", args={
            "operation_context": operation_context,"risk_assessment": risk_assessment,"data_sensitivity": data_sensitivity,
        }, mode="request")
        return result
    def SemanticIntegratorAgent(self, transformed_data: types.ParsedData,business_domain: str,existing_ontologies: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SemanticIntegratorAgent", args={
            "transformed_data": transformed_data,"business_domain": business_domain,"existing_ontologies": existing_ontologies,
        }, mode="request")
        return result
    def SourceDiscoveryAgent(self, business_context: types.BusinessContext,platform_capabilities: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SourceDiscoveryAgent", args={
            "business_context": business_context,"platform_capabilities": platform_capabilities,
        }, mode="request")
        return result
    def SupervisorAgent(self, sow_document: str,document_format: str,human_feedback: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SupervisorAgent", args={
            "sow_document": sow_document,"document_format": document_format,"human_feedback": human_feedback,
        }, mode="request")
        return result
    

class BamlHttpStreamRequestClient:
    __options: DoNotUseDirectlyCallManager

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options

    def BusinessContextAgent(self, business_question: str,success_criteria: str,timeline: str,budget: str,risk_tolerance: str,persona_id: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="BusinessContextAgent", args={
            "business_question": business_question,"success_criteria": success_criteria,"timeline": timeline,"budget": budget,"risk_tolerance": risk_tolerance,"persona_id": persona_id,
        }, mode="stream")
        return result
    def CongestionManagementAgent(self, current_traffic: typing.Dict[str, int],lock_queues: typing.Dict[str, int],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="CongestionManagementAgent", args={
            "current_traffic": current_traffic,"lock_queues": lock_queues,
        }, mode="stream")
        return result
    def DataFetcherAgent(self, data_sources: typing.List["types.DataSource"],security_requirements: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DataFetcherAgent", args={
            "data_sources": data_sources,"security_requirements": security_requirements,
        }, mode="stream")
        return result
    def DataParserAgent(self, raw_data: str,data_format: str,schema_hints: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DataParserAgent", args={
            "raw_data": raw_data,"data_format": data_format,"schema_hints": schema_hints,
        }, mode="stream")
        return result
    def DataTransformerAgent(self, source_data: types.ParsedData,target_schema: typing.Dict[str, str],business_rules: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DataTransformerAgent", args={
            "source_data": source_data,"target_schema": target_schema,"business_rules": business_rules,
        }, mode="stream")
        return result
    def DecisionSupportAgent(self, current_situation: str,available_options: typing.List["types.RouteOption"],constraints: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="DecisionSupportAgent", args={
            "current_situation": current_situation,"available_options": available_options,"constraints": constraints,
        }, mode="stream")
        return result
    def EconomicOptimizationAgent(self, market_data: typing.Dict[str, float],transport_rates: typing.Dict[str, float],routing_options: typing.List["types.RouteOption"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="EconomicOptimizationAgent", args={
            "market_data": market_data,"transport_rates": transport_rates,"routing_options": routing_options,
        }, mode="stream")
        return result
    def FeasibilityAnalyzerAgent(self, business_context: types.BusinessContext,recommended_sources: typing.List["types.DataSourceRecommendation"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="FeasibilityAnalyzerAgent", args={
            "business_context": business_context,"recommended_sources": recommended_sources,
        }, mode="stream")
        return result
    def HydrologicalRiskAgent(self, waterway_segments: typing.List[str],forecast_period_days: int,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="HydrologicalRiskAgent", args={
            "waterway_segments": waterway_segments,"forecast_period_days": forecast_period_days,
        }, mode="stream")
        return result
    def MultiModalOptimizationAgent(self, origin: str,destination: str,commodity: str,quantity_tons: float,service_requirements: typing.Dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="MultiModalOptimizationAgent", args={
            "origin": origin,"destination": destination,"commodity": commodity,"quantity_tons": quantity_tons,"service_requirements": service_requirements,
        }, mode="stream")
        return result
    def NavigationIntelligenceAgent(self, routing_request: types.RoutingRequest,current_conditions: types.WaterwayConditions,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="NavigationIntelligenceAgent", args={
            "routing_request": routing_request,"current_conditions": current_conditions,
        }, mode="stream")
        return result
    def PersonaResponseAgent(self, base_response: str,persona_id: str,interaction_level: str,technical_depth: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="PersonaResponseAgent", args={
            "base_response": base_response,"persona_id": persona_id,"interaction_level": interaction_level,"technical_depth": technical_depth,
        }, mode="stream")
        return result
    def PlatformCapabilityAgent(self, data_sources: typing.List[str],requirements: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="PlatformCapabilityAgent", args={
            "data_sources": data_sources,"requirements": requirements,
        }, mode="stream")
        return result
    def SOWGeneratorAgent(self, business_context: types.BusinessContext,selected_sources: typing.List["types.DataSourceRecommendation"],feasibility_analysis: types.FeasibilityAnalysis,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SOWGeneratorAgent", args={
            "business_context": business_context,"selected_sources": selected_sources,"feasibility_analysis": feasibility_analysis,
        }, mode="stream")
        return result
    def SOWInterpreterAgent(self, sow_document: str,document_format: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SOWInterpreterAgent", args={
            "sow_document": sow_document,"document_format": document_format,
        }, mode="stream")
        return result
    def SecurityDecisionAgent(self, operation_context: str,risk_assessment: str,data_sensitivity: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SecurityDecisionAgent", args={
            "operation_context": operation_context,"risk_assessment": risk_assessment,"data_sensitivity": data_sensitivity,
        }, mode="stream")
        return result
    def SemanticIntegratorAgent(self, transformed_data: types.ParsedData,business_domain: str,existing_ontologies: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SemanticIntegratorAgent", args={
            "transformed_data": transformed_data,"business_domain": business_domain,"existing_ontologies": existing_ontologies,
        }, mode="stream")
        return result
    def SourceDiscoveryAgent(self, business_context: types.BusinessContext,platform_capabilities: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SourceDiscoveryAgent", args={
            "business_context": business_context,"platform_capabilities": platform_capabilities,
        }, mode="stream")
        return result
    def SupervisorAgent(self, sow_document: str,document_format: str,human_feedback: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="SupervisorAgent", args={
            "sow_document": sow_document,"document_format": document_format,"human_feedback": human_feedback,
        }, mode="stream")
        return result
    

b = BamlSyncClient(DoNotUseDirectlyCallManager({}))